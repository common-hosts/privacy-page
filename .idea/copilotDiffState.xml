<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/googleSites.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/googleSites.py" />
              <option name="originalContent" value="import argparse&#10;import html&#10;import re&#10;import subprocess&#10;import base64&#10;import os&#10;import time&#10;import urllib.request&#10;from dataclasses import dataclass&#10;from pathlib import Path&#10;from typing import Optional&#10;&#10;&#10;REPO_ROOT = Path(__file__).resolve().parent&#10;PAGES_DIR = REPO_ROOT / &quot;pages&quot;&#10;INDEX_HTML_PATH = REPO_ROOT / &quot;index.html&quot;&#10;DEFAULT_COMMIT_MESSAGE = &quot;Update privacy page&quot;&#10;&#10;# 固定页面模板：H1 永远为 &quot;Privacy Policy&quot;（居中、黑体、H1 大小）&#10;# 注意：页面标签 &lt;title&gt; 也固定为 Privacy Policy（App 名称不放在标题，以免被要求统一标题）。&#10;FALLBACK_TEMPLATE = &quot;&quot;&quot;&lt;html lang=\&quot;zh-CN\&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=\&quot;utf-8\&quot;&gt;\n  &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width,initial-scale=1\&quot;&gt;\n  &lt;title&gt;Privacy Policy&lt;/title&gt;\n  &lt;style&gt;\n    body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,\&quot;Helvetica Neue\&quot;,Arial;background:#f7f7fb;margin:0;padding:24px}}\n    .container{{max-width:860px;margin:28px auto;background:#fff;border-radius:10px;padding:28px;box-shadow:0 6px 22px rgba(20,20,30,0.06)}}\n    h1{{margin:0 0 18px;font-size:2rem;font-weight:700;text-align:center}}\n    .content{{line-height:1.7;color:#222;white-space:normal}}\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;main class=\&quot;container\&quot;&gt;\n    &lt;h1&gt;Privacy Policy&lt;/h1&gt;\n    &lt;div class=\&quot;content\&quot;&gt;\n{content}\n    &lt;/div&gt;\n  &lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;&quot;&quot;&#10;&#10;&#10;@dataclass&#10;class PageData:&#10;    title: str&#10;    # content can be plain text OR html fragment. use content_is_html to decide.&#10;    content: str&#10;    content_is_html: bool = False&#10;&#10;&#10;# 这里用一个 SSH Host alias（~/.ssh/config 里配置）来固定使用正确 key&#10;# 例如：Host github-common-hosts -&gt; HostName github.com + IdentityFile ~/.ssh/id_ed25519_common_hosts&#10;PREFERRED_GIT_SSH_HOST = (os.environ.get(&quot;PRIVACY_PAGES_SSH_HOST&quot;) or &quot;github-common-hosts&quot;).strip() or &quot;github-common-hosts&quot;&#10;DEFAULT_PAGES_SSH_KEY = Path(os.environ.get(&quot;PRIVACY_PAGES_SSH_KEY&quot;, &quot;~/.ssh/id_ed25519_common_hosts&quot;)).expanduser()&#10;&#10;&#10;def run(&#10;    cmd: list[str],&#10;    cwd: Optional[Path] = None,&#10;    env: Optional[dict[str, str]] = None,&#10;    check: bool = True,&#10;) -&gt; subprocess.CompletedProcess:&#10;    &quot;&quot;&quot;运行命令；失败就打印 stdout/stderr 并抛出。&quot;&quot;&quot;&#10;    merged_env = os.environ.copy()&#10;    if env:&#10;        merged_env.update(env)&#10;&#10;    p = subprocess.run(&#10;        cmd,&#10;        cwd=str(cwd) if cwd else None,&#10;        text=True,&#10;        capture_output=True,&#10;        env=merged_env,&#10;    )&#10;    if check and p.returncode != 0:&#10;        out = (p.stdout or &quot;&quot;).strip()&#10;        err = (p.stderr or &quot;&quot;).strip()&#10;        if out:&#10;            print(out)&#10;        if err:&#10;            print(err)&#10;        raise subprocess.CalledProcessError(p.returncode, cmd, output=p.stdout, stderr=p.stderr)&#10;    return p&#10;&#10;&#10;def _resolve_pages_ssh_key() -&gt; Optional[Path]:&#10;    &quot;&quot;&quot;Resolve which SSH key to use for git push.&quot;&quot;&quot;&#10;    return DEFAULT_PAGES_SSH_KEY if DEFAULT_PAGES_SSH_KEY.exists() else None&#10;&#10;&#10;def _key_loaded_in_agent(key_path: Path) -&gt; bool:&#10;    try:&#10;        pub_path = Path(str(key_path) + &quot;.pub&quot;)&#10;        if not pub_path.exists():&#10;            return False&#10;        pub = pub_path.read_text(encoding=&quot;utf-8&quot;).strip()&#10;        if not pub:&#10;            return False&#10;        p = subprocess.run([&quot;ssh-add&quot;, &quot;-L&quot;], text=True, capture_output=True)&#10;        if p.returncode != 0:&#10;            return False&#10;        # compare pub key body part&#10;        parts = pub.split()&#10;        return len(parts) &gt;= 2 and parts[1] in (p.stdout or &quot;&quot;)&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def _ensure_ssh_agent_has_key() -&gt; None:&#10;    &quot;&quot;&quot;Ensure ssh-agent exists and has the pages SSH key loaded.&#10;&#10;    We DO NOT auto-run ssh-add here (it may prompt for passphrase, which would hang&#10;    when running from scripts). Instead we print a one-time setup hint.&#10;    &quot;&quot;&quot;&#10;    key_path = _resolve_pages_ssh_key()&#10;    if not key_path:&#10;        return&#10;&#10;    # If already loaded, do nothing&#10;    if _key_loaded_in_agent(key_path):&#10;        return&#10;&#10;    print(&#10;        &quot;\n⚠️ 当前环境的 ssh-agent 里还没有加载 GitHub Pages 的 SSH key，脚本将无法自动 push。\n&quot;&#10;        &quot;请在终端手动执行一次（只需一次）：\n&quot;&#10;        f&quot;  ssh-add --apple-use-keychain {key_path}\n&quot;&#10;        &quot;输入 passphrase 后，会保存到 Keychain，之后运行脚本就不会再提示。\n&quot;&#10;    )&#10;&#10;&#10;def _git_env_for_pages_push() -&gt; dict[str, str]:&#10;    &quot;&quot;&quot;Force git/ssh to use the right identity non-interactively.&#10;&#10;    Note:&#10;      - BatchMode=yes =&gt; never prompt for passphrase. If the key isn't loaded in ssh-agent,&#10;        git push will fail fast with a clear error.&#10;    &quot;&quot;&quot;&#10;    _ensure_ssh_agent_has_key()&#10;    return {&#10;        &quot;GIT_SSH_COMMAND&quot;: (&#10;            &quot;ssh -o BatchMode=yes -o IdentitiesOnly=yes &quot;&#10;            &quot;-o StrictHostKeyChecking=accept-new &quot;&#10;            &quot;-o ControlMaster=auto -o ControlPersist=10m -o ControlPath=~/.ssh/cm-%r@%h:%p&quot;&#10;        ),&#10;        &quot;GIT_PROTOCOL&quot;: &quot;version=2&quot;,&#10;    }&#10;&#10;&#10;def _rewrite_remote_to_preferred_host(remote_url: str) -&gt; str:&#10;    &quot;&quot;&quot;Rewrite origin remote url to use our SSH host alias.&#10;&#10;    Example:&#10;      git@github.com:common-hosts/privacy-page.git  -&gt;  git@github-common-hosts:common-hosts/privacy-page.git&#10;    &quot;&quot;&quot;&#10;    u = (remote_url or &quot;&quot;).strip()&#10;    if not u:&#10;        return u&#10;&#10;    m = re.match(r&quot;^git@([^:]+):(.+)$&quot;, u)&#10;    if not m:&#10;        return u&#10;&#10;    host, rest = m.group(1), m.group(2)&#10;    if host == PREFERRED_GIT_SSH_HOST:&#10;        return u&#10;&#10;    if host == &quot;github.com&quot;:&#10;        return f&quot;git@{PREFERRED_GIT_SSH_HOST}:{rest}&quot;&#10;&#10;    return u&#10;&#10;&#10;def get_git_remote_url(remote: str = &quot;origin&quot;) -&gt; str:&#10;    try:&#10;        p = run([&quot;git&quot;, &quot;remote&quot;, &quot;get-url&quot;, remote], cwd=REPO_ROOT)&#10;        return (p.stdout or &quot;&quot;).strip()&#10;    except Exception:&#10;        return &quot;&quot;&#10;&#10;&#10;def _ensure_origin_uses_preferred_host() -&gt; None:&#10;    remote_url = get_git_remote_url(&quot;origin&quot;)&#10;    if not remote_url:&#10;        return&#10;    new_url = _rewrite_remote_to_preferred_host(remote_url)&#10;    if new_url != remote_url:&#10;        run([&quot;git&quot;, &quot;remote&quot;, &quot;set-url&quot;, &quot;origin&quot;, new_url], cwd=REPO_ROOT)&#10;&#10;&#10;def _ensure_git_identity() -&gt; None:&#10;    &quot;&quot;&quot;Prevent commit failures when user.name/user.email not configured.&quot;&quot;&quot;&#10;&#10;    def _cfg(key: str) -&gt; str:&#10;        p = subprocess.run(&#10;            [&quot;git&quot;, &quot;config&quot;, &quot;--get&quot;, key],&#10;            cwd=str(REPO_ROOT),&#10;            text=True,&#10;            capture_output=True,&#10;        )&#10;        return (p.stdout or &quot;&quot;).strip()&#10;&#10;    name = _cfg(&quot;user.name&quot;)&#10;    email = _cfg(&quot;user.email&quot;)&#10;    if not name:&#10;        run([&quot;git&quot;, &quot;config&quot;, &quot;user.name&quot;, &quot;privacy-bot&quot;], cwd=REPO_ROOT)&#10;    if not email:&#10;        run(&#10;            [&quot;git&quot;, &quot;config&quot;, &quot;user.email&quot;, &quot;privacy-bot@users.noreply.github.com&quot;],&#10;            cwd=REPO_ROOT,&#10;        )&#10;&#10;&#10;def get_repo_slug_from_remote(remote_url: str) -&gt; str:&#10;    r&quot;&quot;&quot;Extract owner/repo from git remote url.&#10;&#10;    Supported:&#10;      - SSH: git@github.com:owner/repo.git&#10;      - HTTPS: https://github.com/owner/repo.git&#10;    &quot;&quot;&quot;&#10;    u = (remote_url or &quot;&quot;).strip()&#10;    if not u:&#10;        raise ValueError(f&quot;Unsupported remote url: {remote_url!r}&quot;)&#10;&#10;    # SSH&#10;    m = re.match(r&quot;^git@[^:]+:([^/]+)/(.+?)(?:\.git)?$&quot;, u)&#10;    if m:&#10;        return f&quot;{m.group(1)}/{m.group(2)}&quot;&#10;&#10;    # HTTPS&#10;    m = re.match(r&quot;^https?://[^/]+/([^/]+)/(.+?)(?:\.git)?/?$&quot;, u)&#10;    if m:&#10;        return f&quot;{m.group(1)}/{m.group(2)}&quot;&#10;&#10;    raise ValueError(f&quot;Unsupported remote url: {remote_url!r}&quot;)&#10;&#10;&#10;def github_pages_base_url(repo_slug: str) -&gt; str:&#10;    owner, repo = repo_slug.split(&quot;/&quot;, 1)&#10;    return f&quot;https://{owner}.github.io/{repo}/&quot;&#10;&#10;&#10;def slugify(s: str) -&gt; str:&#10;    &quot;&quot;&quot;Generate safe path slug for GitHub Pages URL.&quot;&quot;&quot;&#10;    s = (s or &quot;&quot;).strip().lower()&#10;    s = re.sub(r&quot;[\s_]+&quot;, &quot;-&quot;, s)&#10;    s = re.sub(r&quot;[^a-z0-9\-]+&quot;, &quot;-&quot;, s)&#10;    s = re.sub(r&quot;-+&quot;, &quot;-&quot;, s).strip(&quot;-&quot;)&#10;    return s or &quot;privacy-policy&quot;&#10;&#10;&#10;def escape_and_preserve_newlines_as_html(text: str) -&gt; str:&#10;    &quot;&quot;&quot;Plain text -&gt; safe HTML, keeping line breaks and indentation for nicer display.&quot;&quot;&quot;&#10;    safe = html.escape(text or &quot;&quot;)&#10;    safe = safe.replace(&quot;  &quot;, &quot;&amp;nbsp;&amp;nbsp;&quot;)&#10;    safe = safe.replace(&quot;\r\n&quot;, &quot;\n&quot;).replace(&quot;\r&quot;, &quot;\n&quot;)&#10;    safe = safe.replace(&quot;\n&quot;, &quot;&lt;br&gt;\n&quot;)&#10;    return safe&#10;&#10;&#10;def encode_id_to_base64_letters(raw_id: str) -&gt; str:&#10;    &quot;&quot;&quot;把编号编码成 base64url 形式（只包含字母/数字/连字符/下划线），更短且可用于 URL 路径。&quot;&quot;&quot;&#10;    raw = (raw_id or &quot;&quot;).strip()&#10;    if not raw:&#10;        return &quot;&quot;&#10;    b = raw.encode(&quot;utf-8&quot;)&#10;    return base64.urlsafe_b64encode(b).decode(&quot;ascii&quot;).rstrip(&quot;=&quot;)&#10;&#10;&#10;def strip_leading_privacy_policy(text: str) -&gt; str:&#10;    &quot;&quot;&quot;去掉正文最前面的 'Privacy Policy' + 空行，避免页面出现重复标题。&quot;&quot;&quot;&#10;    if not text:&#10;        return &quot;&quot;&#10;    t = text.lstrip(&quot;\ufeff\n\r\t &quot;)&#10;    if re.match(r&quot;(?is)^privacy\s*policy\s*(\n|\r\n)\s*(\n|\r\n)&quot;, t):&#10;        t = re.sub(r&quot;(?is)^privacy\s*policy\s*(\n|\r\n)\s*(\n|\r\n)&quot;, &quot;&quot;, t, count=1)&#10;    return t&#10;&#10;&#10;def render_html(page: PageData) -&gt; str:&#10;    content_source = page.content&#10;    if not page.content_is_html:&#10;        content_source = strip_leading_privacy_policy(content_source)&#10;&#10;    content_html = content_source if page.content_is_html else escape_and_preserve_newlines_as_html(content_source)&#10;    return FALLBACK_TEMPLATE.format(content=content_html)&#10;&#10;&#10;def write_privacy_page(page: PageData, page_slug: str) -&gt; Path:&#10;    &quot;&quot;&quot;Write to pages/&lt;slug&gt;/index.html and return the written path.&quot;&quot;&quot;&#10;    page_dir = PAGES_DIR / page_slug&#10;    page_dir.mkdir(parents=True, exist_ok=True)&#10;    out_path = page_dir / &quot;index.html&quot;&#10;    out_path.write_text(render_html(page), encoding=&quot;utf-8&quot;)&#10;    return out_path&#10;&#10;&#10;def write_root_landing(latest_url: str) -&gt; None:&#10;    landing = (&#10;        f&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;0; url={html.escape(latest_url)}\&quot;&gt;&lt;/head&gt;\n&quot;&#10;        f&quot;&lt;body&gt;Redirecting to &lt;a href=\&quot;{html.escape(latest_url)}\&quot;&gt;{html.escape(latest_url)}&lt;/a&gt;...&lt;/body&gt;&lt;/html&gt;\n&quot;&#10;    )&#10;    INDEX_HTML_PATH.write_text(landing, encoding=&quot;utf-8&quot;)&#10;&#10;&#10;def read_content_from_file(path: Path) -&gt; str:&#10;    return path.read_text(encoding=&quot;utf-8&quot;)&#10;&#10;&#10;def git_commit_push(commit_message: str) -&gt; None:&#10;    &quot;&quot;&quot;git add/commit/push; if nothing to commit, still push to be safe.&quot;&quot;&quot;&#10;    _ensure_origin_uses_preferred_host()&#10;    _ensure_git_identity()&#10;&#10;    run([&quot;git&quot;, &quot;add&quot;, &quot;-A&quot;], cwd=REPO_ROOT)&#10;&#10;    st = run([&quot;git&quot;, &quot;status&quot;, &quot;--porcelain&quot;], cwd=REPO_ROOT, check=False)&#10;    if not (st.stdout or &quot;&quot;).strip():&#10;        print(&quot;ℹ️ 没有文件变更，跳过 commit。&quot;)&#10;    else:&#10;        run([&quot;git&quot;, &quot;commit&quot;, &quot;-m&quot;, commit_message], cwd=REPO_ROOT)&#10;&#10;    env = _git_env_for_pages_push()&#10;    b = run([&quot;git&quot;, &quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;], cwd=REPO_ROOT)&#10;    branch = (b.stdout or &quot;main&quot;).strip() or &quot;main&quot;&#10;&#10;    # Push using origin (already rewritten to preferred host).&#10;    run([&quot;git&quot;, &quot;push&quot;, &quot;origin&quot;, branch], cwd=REPO_ROOT, env=env)&#10;&#10;&#10;def wait_until_url_ready(url: str, timeout_seconds: int = 120, interval_seconds: float = 3.0) -&gt; bool:&#10;    &quot;&quot;&quot;Poll the published GitHub Pages URL until it returns HTTP 200。&#10;&#10;    GitHub Pages often has a small build/deploy delay. This prevents the&#10;    &quot;new page 404, old page works&quot; confusion.&#10;    &quot;&quot;&quot;&#10;    end = time.time() + timeout_seconds&#10;    last_err = &quot;&quot;&#10;    while time.time() &lt; end:&#10;        try:&#10;            req = urllib.request.Request(url, headers={&quot;User-Agent&quot;: &quot;Mozilla/5.0&quot;})&#10;            with urllib.request.urlopen(req, timeout=20) as resp:&#10;                if getattr(resp, &quot;status&quot;, 200) == 200:&#10;                    return True&#10;        except Exception as e:&#10;            last_err = str(e)&#10;        time.sleep(interval_seconds)&#10;&#10;    if last_err:&#10;        print(f&quot;⚠️ 页面在 {timeout_seconds}s 内仍不可访问（可能还在部署中）：{last_err}&quot;)&#10;    else:&#10;        print(f&quot;⚠️ 页面在 {timeout_seconds}s 内仍不可访问（可能还在部署中）。&quot;)&#10;    return False&#10;&#10;&#10;# --- Clipboard helpers (macOS) ---&#10;def copy_to_clipboard_macos(text: str) -&gt; bool:&#10;    &quot;&quot;&quot;Copy text to macOS clipboard using pbcopy.&quot;&quot;&quot;&#10;    if not text:&#10;        return False&#10;    try:&#10;        subprocess.run([&quot;pbcopy&quot;], input=text.encode(&quot;utf-8&quot;), check=True)&#10;        return True&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def show_macos_toast(message: str, seconds: int = 3) -&gt; None:&#10;    &quot;&quot;&quot;Best-effort toast via AppleScript (no hard failure if blocked).&quot;&quot;&quot;&#10;    msg = (message or &quot;&quot;).replace('&quot;', &quot;\\\&quot;&quot;)&#10;    try:&#10;        subprocess.run(&#10;            [&quot;osascript&quot;, &quot;-e&quot;, f'display notification &quot;{msg}&quot; with title &quot;PrivacyTools&quot;'],&#10;            check=False,&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser(description=&quot;Publish per-app privacy page to GitHub Pages (no overwrite).&quot;)&#10;    parser.add_argument(&quot;--title&quot;, required=True, help=&quot;App name (for logging only; page H1/title are fixed)&quot;)&#10;    parser.add_argument(&quot;--content&quot;, help=&quot;Page content (plain text).&quot;)&#10;    parser.add_argument(&quot;--content-file&quot;, help=&quot;Read content from a text file instead of --content&quot;)&#10;    parser.add_argument(&quot;--content-is-html&quot;, action=&quot;store_true&quot;, help=&quot;Treat content as HTML (no escaping).&quot;)&#10;    parser.add_argument(&quot;--slug&quot;, help=&quot;Optional custom slug; default: encoded_id + '-' + slugify(title)&quot;)&#10;    parser.add_argument(&quot;--id&quot;, help=&quot;Optional raw ID (e.g. IGT1128). If provided, will be encoded into slug prefix.&quot;)&#10;    parser.add_argument(&quot;--commit-message&quot;, default=DEFAULT_COMMIT_MESSAGE, help=&quot;Git commit message&quot;)&#10;    parser.add_argument(&quot;--no-push&quot;, action=&quot;store_true&quot;, help=&quot;Only write files, do not commit/push&quot;)&#10;    parser.add_argument(&#10;        &quot;--no-wait&quot;,&#10;        action=&quot;store_true&quot;,&#10;        help=&quot;Do not wait/poll for GitHub Pages deployment (faster; URL may 404 for a bit).&quot;,&#10;    )&#10;&#10;    args = parser.parse_args()&#10;&#10;    if args.content_file:&#10;        content = read_content_from_file(Path(args.content_file))&#10;    else:&#10;        content = args.content or &quot;&quot;&#10;&#10;    # Build slug&#10;    if args.slug:&#10;        page_slug = args.slug&#10;    else:&#10;        id_prefix = encode_id_to_base64_letters(args.id or &quot;&quot;)&#10;        if id_prefix:&#10;            page_slug = f&quot;{id_prefix}-{slugify(args.title)}&quot;&#10;        else:&#10;            page_slug = slugify(args.title)&#10;&#10;    page = PageData(title=args.title, content=content, content_is_html=args.content_is_html)&#10;    out_path = write_privacy_page(page, page_slug)&#10;&#10;    repo_slug = get_repo_slug_from_remote(get_git_remote_url(&quot;origin&quot;))&#10;    page_url = github_pages_base_url(repo_slug) + f&quot;pages/{page_slug}/&quot;&#10;&#10;    # optional: write root index.html redirect for convenience&#10;    try:&#10;        write_root_landing(page_url)&#10;    except Exception:&#10;        pass&#10;&#10;    print(f&quot;✅ Wrote privacy page: {out_path}&quot;)&#10;    print(f&quot; Page URL: {page_url}&quot;)&#10;&#10;    if args.no_push:&#10;        print(&quot;ℹ️ --no-push used. Skipping git commit/push.&quot;)&#10;        return&#10;&#10;    try:&#10;        git_commit_push(args.commit_message)&#10;&#10;        # give user a quick clipboard copy for convenience&#10;        if copy_to_clipboard_macos(page_url):&#10;            show_macos_toast(&quot;发布链接已复制&quot;, seconds=3)&#10;&#10;        # Default speed: don't wait unless user explicitly wants it&#10;        if not args.no_wait:&#10;            print(&quot;⏳ 等待 GitHub Pages 部署生效...&quot;)&#10;            if wait_until_url_ready(page_url, timeout_seconds=180, interval_seconds=4.0):&#10;                print(&quot;✅ 页面已可访问。&quot;)&#10;            else:&#10;                print(&quot;ℹ️ 可能需要再等一会儿再刷新浏览器（GitHub Pages 有部署延迟）。&quot;)&#10;&#10;    except subprocess.CalledProcessError as e:&#10;        err = (e.stderr or &quot;&quot;).strip()&#10;        out = (e.output or &quot;&quot;).strip()&#10;        if out:&#10;            print(out)&#10;        if err:&#10;            print(err)&#10;        raise SystemExit(f&quot;命令失败: {e.cmd} (exit {e.returncode})&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="import argparse&#10;import html&#10;import re&#10;import subprocess&#10;import base64&#10;import os&#10;import time&#10;import urllib.request&#10;from dataclasses import dataclass&#10;from pathlib import Path&#10;from typing import Optional&#10;&#10;&#10;REPO_ROOT = Path(__file__).resolve().parent&#10;PAGES_DIR = REPO_ROOT / &quot;pages&quot;&#10;INDEX_HTML_PATH = REPO_ROOT / &quot;index.html&quot;&#10;DEFAULT_COMMIT_MESSAGE = &quot;Update privacy page&quot;&#10;&#10;# 固定页面模板：H1 永远为 &quot;Privacy Policy&quot;（居中、黑体、H1 大小）&#10;# 注意：页面标签 &lt;title&gt; 也固定为 Privacy Policy（App 名称不放在标题，以免被要求统一标题）。&#10;FALLBACK_TEMPLATE = &quot;&quot;&quot;&lt;html lang=\&quot;zh-CN\&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=\&quot;utf-8\&quot;&gt;\n  &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width,initial-scale=1\&quot;&gt;\n  &lt;title&gt;Privacy Policy&lt;/title&gt;\n  &lt;style&gt;\n    body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,\&quot;Helvetica Neue\&quot;,Arial;background:#f7f7fb;margin:0;padding:24px}}\n    .container{{max-width:860px;margin:28px auto;background:#fff;border-radius:10px;padding:28px;box-shadow:0 6px 22px rgba(20,20,30,0.06)}}\n    h1{{margin:0 0 18px;font-size:2rem;font-weight:700;text-align:center}}\n    .content{{line-height:1.7;color:#222;white-space:normal}}\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;main class=\&quot;container\&quot;&gt;\n    &lt;h1&gt;Privacy Policy&lt;/h1&gt;\n    &lt;div class=\&quot;content\&quot;&gt;\n{content}\n    &lt;/div&gt;\n  &lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;&quot;&quot;&#10;&#10;&#10;@dataclass&#10;class PageData:&#10;    title: str&#10;    # content can be plain text OR html fragment. use content_is_html to decide.&#10;    content: str&#10;    content_is_html: bool = False&#10;&#10;&#10;# 这里用一个 SSH Host alias（~/.ssh/config 里配置）来固定使用正确 key&#10;# 例如：Host github-common-hosts -&gt; HostName github.com + IdentityFile ~/.ssh/id_ed25519_common_hosts&#10;PREFERRED_GIT_SSH_HOST = (os.environ.get(&quot;PRIVACY_PAGES_SSH_HOST&quot;) or &quot;github-common-hosts&quot;).strip() or &quot;github-common-hosts&quot;&#10;DEFAULT_PAGES_SSH_KEY = Path(os.environ.get(&quot;PRIVACY_PAGES_SSH_KEY&quot;, &quot;~/.ssh/id_ed25519_common_hosts&quot;)).expanduser()&#10;&#10;&#10;def run(&#10;    cmd: list[str],&#10;    cwd: Optional[Path] = None,&#10;    env: Optional[dict[str, str]] = None,&#10;    check: bool = True,&#10;) -&gt; subprocess.CompletedProcess:&#10;    &quot;&quot;&quot;运行命令；失败就打印 stdout/stderr 并抛出。&#10;&#10;    Windows 上默认控制台编码可能是 GBK，git 输出里如果出现 utf-8 字符会触发&#10;    UnicodeDecodeError。这里统一用 utf-8 解码并用 replace 兜底，保证不会崩。&#10;    &quot;&quot;&quot;&#10;    merged_env = os.environ.copy()&#10;    if env:&#10;        merged_env.update(env)&#10;&#10;    p = subprocess.run(&#10;        cmd,&#10;        cwd=str(cwd) if cwd else None,&#10;        text=True,&#10;        encoding=&quot;utf-8&quot;,&#10;        errors=&quot;replace&quot;,&#10;        capture_output=True,&#10;        env=merged_env,&#10;    )&#10;    if check and p.returncode != 0:&#10;        out = (p.stdout or &quot;&quot;).strip()&#10;        err = (p.stderr or &quot;&quot;).strip()&#10;        if out:&#10;            print(out)&#10;        if err:&#10;            print(err)&#10;        raise subprocess.CalledProcessError(p.returncode, cmd, output=p.stdout, stderr=p.stderr)&#10;    return p&#10;&#10;&#10;def _resolve_pages_ssh_key() -&gt; Optional[Path]:&#10;    &quot;&quot;&quot;Resolve which SSH key to use for git push.&quot;&quot;&quot;&#10;    return DEFAULT_PAGES_SSH_KEY if DEFAULT_PAGES_SSH_KEY.exists() else None&#10;&#10;&#10;def _key_loaded_in_agent(key_path: Path) -&gt; bool:&#10;    try:&#10;        pub_path = Path(str(key_path) + &quot;.pub&quot;)&#10;        if not pub_path.exists():&#10;            return False&#10;        pub = pub_path.read_text(encoding=&quot;utf-8&quot;).strip()&#10;        if not pub:&#10;            return False&#10;        p = subprocess.run([&quot;ssh-add&quot;, &quot;-L&quot;], text=True, capture_output=True)&#10;        if p.returncode != 0:&#10;            return False&#10;        # compare pub key body part&#10;        parts = pub.split()&#10;        return len(parts) &gt;= 2 and parts[1] in (p.stdout or &quot;&quot;)&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def _ensure_ssh_agent_has_key() -&gt; None:&#10;    &quot;&quot;&quot;Ensure ssh-agent exists and has the pages SSH key loaded.&#10;&#10;    We DO NOT auto-run ssh-add here (it may prompt for passphrase, which would hang&#10;    when running from scripts). Instead we print a one-time setup hint.&#10;    &quot;&quot;&quot;&#10;    key_path = _resolve_pages_ssh_key()&#10;    if not key_path:&#10;        return&#10;&#10;    # If already loaded, do nothing&#10;    if _key_loaded_in_agent(key_path):&#10;        return&#10;&#10;    print(&#10;        &quot;\n⚠️ 当前环境的 ssh-agent 里还没有加载 GitHub Pages 的 SSH key，脚本将无法自动 push。\n&quot;&#10;        &quot;请在终端手动执行一次（只需一次）：\n&quot;&#10;        f&quot;  ssh-add --apple-use-keychain {key_path}\n&quot;&#10;        &quot;输入 passphrase 后，会保存到 Keychain，之后运行脚本就不会再提示。\n&quot;&#10;    )&#10;&#10;&#10;def _git_env_for_pages_push() -&gt; dict[str, str]:&#10;    &quot;&quot;&quot;Force git/ssh to use the right identity non-interactively.&#10;&#10;    Note:&#10;      - BatchMode=yes =&gt; never prompt for passphrase. If the key isn't loaded in ssh-agent,&#10;        git push will fail fast with a clear error.&#10;    &quot;&quot;&quot;&#10;    _ensure_ssh_agent_has_key()&#10;    return {&#10;        &quot;GIT_SSH_COMMAND&quot;: (&#10;            &quot;ssh -o BatchMode=yes -o IdentitiesOnly=yes &quot;&#10;            &quot;-o StrictHostKeyChecking=accept-new &quot;&#10;            &quot;-o ControlMaster=auto -o ControlPersist=10m -o ControlPath=~/.ssh/cm-%r@%h:%p&quot;&#10;        ),&#10;        &quot;GIT_PROTOCOL&quot;: &quot;version=2&quot;,&#10;    }&#10;&#10;&#10;def _rewrite_remote_to_preferred_host(remote_url: str) -&gt; str:&#10;    &quot;&quot;&quot;Rewrite origin remote url to use our SSH host alias.&#10;&#10;    Example:&#10;      git@github.com:common-hosts/privacy-page.git  -&gt;  git@github-common-hosts:common-hosts/privacy-page.git&#10;    &quot;&quot;&quot;&#10;    u = (remote_url or &quot;&quot;).strip()&#10;    if not u:&#10;        return u&#10;&#10;    m = re.match(r&quot;^git@([^:]+):(.+)$&quot;, u)&#10;    if not m:&#10;        return u&#10;&#10;    host, rest = m.group(1), m.group(2)&#10;    if host == PREFERRED_GIT_SSH_HOST:&#10;        return u&#10;&#10;    if host == &quot;github.com&quot;:&#10;        return f&quot;git@{PREFERRED_GIT_SSH_HOST}:{rest}&quot;&#10;&#10;    return u&#10;&#10;&#10;def get_git_remote_url(remote: str = &quot;origin&quot;) -&gt; str:&#10;    try:&#10;        p = run([&quot;git&quot;, &quot;remote&quot;, &quot;get-url&quot;, remote], cwd=REPO_ROOT)&#10;        return (p.stdout or &quot;&quot;).strip()&#10;    except Exception:&#10;        return &quot;&quot;&#10;&#10;&#10;def _ensure_origin_uses_preferred_host() -&gt; None:&#10;    remote_url = get_git_remote_url(&quot;origin&quot;)&#10;    if not remote_url:&#10;        return&#10;    new_url = _rewrite_remote_to_preferred_host(remote_url)&#10;    if new_url != remote_url:&#10;        run([&quot;git&quot;, &quot;remote&quot;, &quot;set-url&quot;, &quot;origin&quot;, new_url], cwd=REPO_ROOT)&#10;&#10;&#10;def _ensure_git_identity() -&gt; None:&#10;    &quot;&quot;&quot;Prevent commit failures when user.name/user.email not configured.&quot;&quot;&quot;&#10;&#10;    def _cfg(key: str) -&gt; str:&#10;        p = subprocess.run(&#10;            [&quot;git&quot;, &quot;config&quot;, &quot;--get&quot;, key],&#10;            cwd=str(REPO_ROOT),&#10;            text=True,&#10;            capture_output=True,&#10;        )&#10;        return (p.stdout or &quot;&quot;).strip()&#10;&#10;    name = _cfg(&quot;user.name&quot;)&#10;    email = _cfg(&quot;user.email&quot;)&#10;    if not name:&#10;        run([&quot;git&quot;, &quot;config&quot;, &quot;user.name&quot;, &quot;privacy-bot&quot;], cwd=REPO_ROOT)&#10;    if not email:&#10;        run(&#10;            [&quot;git&quot;, &quot;config&quot;, &quot;user.email&quot;, &quot;privacy-bot@users.noreply.github.com&quot;],&#10;            cwd=REPO_ROOT,&#10;        )&#10;&#10;&#10;def get_repo_slug_from_remote(remote_url: str) -&gt; str:&#10;    r&quot;&quot;&quot;Extract owner/repo from git remote url.&#10;&#10;    Supported:&#10;      - SSH: git@github.com:owner/repo.git&#10;      - HTTPS: https://github.com/owner/repo.git&#10;    &quot;&quot;&quot;&#10;    u = (remote_url or &quot;&quot;).strip()&#10;    if not u:&#10;        raise ValueError(f&quot;Unsupported remote url: {remote_url!r}&quot;)&#10;&#10;    # SSH&#10;    m = re.match(r&quot;^git@[^:]+:([^/]+)/(.+?)(?:\.git)?$&quot;, u)&#10;    if m:&#10;        return f&quot;{m.group(1)}/{m.group(2)}&quot;&#10;&#10;    # HTTPS&#10;    m = re.match(r&quot;^https?://[^/]+/([^/]+)/(.+?)(?:\.git)?/?$&quot;, u)&#10;    if m:&#10;        return f&quot;{m.group(1)}/{m.group(2)}&quot;&#10;&#10;    raise ValueError(f&quot;Unsupported remote url: {remote_url!r}&quot;)&#10;&#10;&#10;def github_pages_base_url(repo_slug: str) -&gt; str:&#10;    owner, repo = repo_slug.split(&quot;/&quot;, 1)&#10;    return f&quot;https://{owner}.github.io/{repo}/&quot;&#10;&#10;&#10;def slugify(s: str) -&gt; str:&#10;    &quot;&quot;&quot;Generate safe path slug for GitHub Pages URL.&quot;&quot;&quot;&#10;    s = (s or &quot;&quot;).strip().lower()&#10;    s = re.sub(r&quot;[\s_]+&quot;, &quot;-&quot;, s)&#10;    s = re.sub(r&quot;[^a-z0-9\-]+&quot;, &quot;-&quot;, s)&#10;    s = re.sub(r&quot;-+&quot;, &quot;-&quot;, s).strip(&quot;-&quot;)&#10;    return s or &quot;privacy-policy&quot;&#10;&#10;&#10;def escape_and_preserve_newlines_as_html(text: str) -&gt; str:&#10;    &quot;&quot;&quot;Plain text -&gt; safe HTML, keeping line breaks and indentation for nicer display.&quot;&quot;&quot;&#10;    safe = html.escape(text or &quot;&quot;)&#10;    safe = safe.replace(&quot;  &quot;, &quot;&amp;nbsp;&amp;nbsp;&quot;)&#10;    safe = safe.replace(&quot;\r\n&quot;, &quot;\n&quot;).replace(&quot;\r&quot;, &quot;\n&quot;)&#10;    safe = safe.replace(&quot;\n&quot;, &quot;&lt;br&gt;\n&quot;)&#10;    return safe&#10;&#10;&#10;def encode_id_to_base64_letters(raw_id: str) -&gt; str:&#10;    &quot;&quot;&quot;把编号编码成 base64url 形式（只包含字母/数字/连字符/下划线），更短且可用于 URL 路径。&quot;&quot;&quot;&#10;    raw = (raw_id or &quot;&quot;).strip()&#10;    if not raw:&#10;        return &quot;&quot;&#10;    b = raw.encode(&quot;utf-8&quot;)&#10;    return base64.urlsafe_b64encode(b).decode(&quot;ascii&quot;).rstrip(&quot;=&quot;)&#10;&#10;&#10;def strip_leading_privacy_policy(text: str) -&gt; str:&#10;    &quot;&quot;&quot;去掉正文最前面的 'Privacy Policy' + 空行，避免页面出现重复标题。&quot;&quot;&quot;&#10;    if not text:&#10;        return &quot;&quot;&#10;    t = text.lstrip(&quot;\ufeff\n\r\t &quot;)&#10;    if re.match(r&quot;(?is)^privacy\s*policy\s*(\n|\r\n)\s*(\n|\r\n)&quot;, t):&#10;        t = re.sub(r&quot;(?is)^privacy\s*policy\s*(\n|\r\n)\s*(\n|\r\n)&quot;, &quot;&quot;, t, count=1)&#10;    return t&#10;&#10;&#10;def render_html(page: PageData) -&gt; str:&#10;    content_source = page.content&#10;    if not page.content_is_html:&#10;        content_source = strip_leading_privacy_policy(content_source)&#10;&#10;    content_html = content_source if page.content_is_html else escape_and_preserve_newlines_as_html(content_source)&#10;    return FALLBACK_TEMPLATE.format(content=content_html)&#10;&#10;&#10;def write_privacy_page(page: PageData, page_slug: str) -&gt; Path:&#10;    &quot;&quot;&quot;Write to pages/&lt;slug&gt;/index.html and return the written path.&quot;&quot;&quot;&#10;    page_dir = PAGES_DIR / page_slug&#10;    page_dir.mkdir(parents=True, exist_ok=True)&#10;    out_path = page_dir / &quot;index.html&quot;&#10;    out_path.write_text(render_html(page), encoding=&quot;utf-8&quot;)&#10;    return out_path&#10;&#10;&#10;def write_root_landing(latest_url: str) -&gt; None:&#10;    landing = (&#10;        f&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;0; url={html.escape(latest_url)}\&quot;&gt;&lt;/head&gt;\n&quot;&#10;        f&quot;&lt;body&gt;Redirecting to &lt;a href=\&quot;{html.escape(latest_url)}\&quot;&gt;{html.escape(latest_url)}&lt;/a&gt;...&lt;/body&gt;&lt;/html&gt;\n&quot;&#10;    )&#10;    INDEX_HTML_PATH.write_text(landing, encoding=&quot;utf-8&quot;)&#10;&#10;&#10;def read_content_from_file(path: Path) -&gt; str:&#10;    return path.read_text(encoding=&quot;utf-8&quot;)&#10;&#10;&#10;def git_commit_push(commit_message: str) -&gt; None:&#10;    &quot;&quot;&quot;git add/commit/push; if nothing to commit, still push to be safe.&quot;&quot;&quot;&#10;    _ensure_origin_uses_preferred_host()&#10;    _ensure_git_identity()&#10;&#10;    run([&quot;git&quot;, &quot;add&quot;, &quot;-A&quot;], cwd=REPO_ROOT)&#10;&#10;    st = run([&quot;git&quot;, &quot;status&quot;, &quot;--porcelain&quot;], cwd=REPO_ROOT, check=False)&#10;    if not (st.stdout or &quot;&quot;).strip():&#10;        print(&quot;ℹ️ 没有文件变更，跳过 commit。&quot;)&#10;    else:&#10;        run([&quot;git&quot;, &quot;commit&quot;, &quot;-m&quot;, commit_message], cwd=REPO_ROOT)&#10;&#10;    env = _git_env_for_pages_push()&#10;    b = run([&quot;git&quot;, &quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;], cwd=REPO_ROOT)&#10;    branch = (b.stdout or &quot;main&quot;).strip() or &quot;main&quot;&#10;&#10;    # Push using origin (already rewritten to preferred host).&#10;    run([&quot;git&quot;, &quot;push&quot;, &quot;origin&quot;, branch], cwd=REPO_ROOT, env=env)&#10;&#10;&#10;def wait_until_url_ready(url: str, timeout_seconds: int = 120, interval_seconds: float = 3.0) -&gt; bool:&#10;    &quot;&quot;&quot;Poll the published GitHub Pages URL until it returns HTTP 200。&#10;&#10;    GitHub Pages often has a small build/deploy delay. This prevents the&#10;    &quot;new page 404, old page works&quot; confusion.&#10;    &quot;&quot;&quot;&#10;    end = time.time() + timeout_seconds&#10;    last_err = &quot;&quot;&#10;    while time.time() &lt; end:&#10;        try:&#10;            req = urllib.request.Request(url, headers={&quot;User-Agent&quot;: &quot;Mozilla/5.0&quot;})&#10;            with urllib.request.urlopen(req, timeout=20) as resp:&#10;                if getattr(resp, &quot;status&quot;, 200) == 200:&#10;                    return True&#10;        except Exception as e:&#10;            last_err = str(e)&#10;        time.sleep(interval_seconds)&#10;&#10;    if last_err:&#10;        print(f&quot;⚠️ 页面在 {timeout_seconds}s 内仍不可访问（可能还在部署中）：{last_err}&quot;)&#10;    else:&#10;        print(f&quot;⚠️ 页面在 {timeout_seconds}s 内仍不可访问（可能还在部署中）。&quot;)&#10;    return False&#10;&#10;&#10;# --- Clipboard helpers (macOS) ---&#10;def copy_to_clipboard_macos(text: str) -&gt; bool:&#10;    &quot;&quot;&quot;Copy text to macOS clipboard using pbcopy.&quot;&quot;&quot;&#10;    if not text:&#10;        return False&#10;    try:&#10;        subprocess.run([&quot;pbcopy&quot;], input=text.encode(&quot;utf-8&quot;), check=True)&#10;        return True&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def show_macos_toast(message: str, seconds: int = 3) -&gt; None:&#10;    &quot;&quot;&quot;Best-effort toast via AppleScript (no hard failure if blocked).&quot;&quot;&quot;&#10;    msg = (message or &quot;&quot;).replace('&quot;', &quot;\\\&quot;&quot;)&#10;    try:&#10;        subprocess.run(&#10;            [&quot;osascript&quot;, &quot;-e&quot;, f'display notification &quot;{msg}&quot; with title &quot;PrivacyTools&quot;'],&#10;            check=False,&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser(description=&quot;Publish per-app privacy page to GitHub Pages (no overwrite).&quot;)&#10;    parser.add_argument(&quot;--title&quot;, required=True, help=&quot;App name (for logging only; page H1/title are fixed)&quot;)&#10;    parser.add_argument(&quot;--content&quot;, help=&quot;Page content (plain text).&quot;)&#10;    parser.add_argument(&quot;--content-file&quot;, help=&quot;Read content from a text file instead of --content&quot;)&#10;    parser.add_argument(&quot;--content-is-html&quot;, action=&quot;store_true&quot;, help=&quot;Treat content as HTML (no escaping).&quot;)&#10;    parser.add_argument(&quot;--slug&quot;, help=&quot;Optional custom slug; default: encoded_id + '-' + slugify(title)&quot;)&#10;    parser.add_argument(&quot;--id&quot;, help=&quot;Optional raw ID (e.g. IGT1128). If provided, will be encoded into slug prefix.&quot;)&#10;    parser.add_argument(&quot;--commit-message&quot;, default=DEFAULT_COMMIT_MESSAGE, help=&quot;Git commit message&quot;)&#10;    parser.add_argument(&quot;--no-push&quot;, action=&quot;store_true&quot;, help=&quot;Only write files, do not commit/push&quot;)&#10;    parser.add_argument(&#10;        &quot;--no-wait&quot;,&#10;        action=&quot;store_true&quot;,&#10;        help=&quot;Do not wait/poll for GitHub Pages deployment (faster; URL may 404 for a bit).&quot;,&#10;    )&#10;&#10;    args = parser.parse_args()&#10;&#10;    if args.content_file:&#10;        content = read_content_from_file(Path(args.content_file))&#10;    else:&#10;        content = args.content or &quot;&quot;&#10;&#10;    # Build slug&#10;    if args.slug:&#10;        page_slug = args.slug&#10;    else:&#10;        id_prefix = encode_id_to_base64_letters(args.id or &quot;&quot;)&#10;        if id_prefix:&#10;            page_slug = f&quot;{id_prefix}-{slugify(args.title)}&quot;&#10;        else:&#10;            page_slug = slugify(args.title)&#10;&#10;    page = PageData(title=args.title, content=content, content_is_html=args.content_is_html)&#10;    out_path = write_privacy_page(page, page_slug)&#10;&#10;    repo_slug = get_repo_slug_from_remote(get_git_remote_url(&quot;origin&quot;))&#10;    page_url = github_pages_base_url(repo_slug) + f&quot;pages/{page_slug}/&quot;&#10;&#10;    # optional: write root index.html redirect for convenience&#10;    try:&#10;        write_root_landing(page_url)&#10;    except Exception:&#10;        pass&#10;&#10;    print(f&quot;✅ Wrote privacy page: {out_path}&quot;)&#10;    print(f&quot; Page URL: {page_url}&quot;)&#10;&#10;    if args.no_push:&#10;        print(&quot;ℹ️ --no-push used. Skipping git commit/push.&quot;)&#10;        return&#10;&#10;    try:&#10;        git_commit_push(args.commit_message)&#10;&#10;        # give user a quick clipboard copy for convenience&#10;        if copy_to_clipboard_macos(page_url):&#10;            show_macos_toast(&quot;发布链接已复制&quot;, seconds=3)&#10;&#10;        # Default speed: don't wait unless user explicitly wants it&#10;        if not args.no_wait:&#10;            print(&quot;⏳ 等待 GitHub Pages 部署生效...&quot;)&#10;            if wait_until_url_ready(page_url, timeout_seconds=180, interval_seconds=4.0):&#10;                print(&quot;✅ 页面已可访问。&quot;)&#10;            else:&#10;                print(&quot;ℹ️ 可能需要再等一会儿再刷新浏览器（GitHub Pages 有部署延迟）。&quot;)&#10;&#10;    except subprocess.CalledProcessError as e:&#10;        err = (e.stderr or &quot;&quot;).strip()&#10;        out = (e.output or &quot;&quot;).strip()&#10;        if out:&#10;            print(out)&#10;        if err:&#10;            print(err)&#10;        raise SystemExit(f&quot;命令失败: {e.cmd} (exit {e.returncode})&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>