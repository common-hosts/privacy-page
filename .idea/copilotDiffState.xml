<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/../.ssh/config">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../.ssh/config" />
              <option name="originalContent" value="Host github-common-hosts&#10;  HostName github.com&#10;  User git&#10;  IdentityFile ~/.ssh/id_ed25519_common_hosts&#10;  IdentitiesOnly yes&#10;  AddKeysToAgent yes&#10;  UseKeychain yes&#10;&#10;" />
              <option name="updatedContent" value="Host github-common-hosts&#10;  HostName github.com&#10;  User git&#10;  IdentityFile ~/.ssh/id_ed25519_common_hosts&#10;  IdentitiesOnly yes&#10;  AddKeysToAgent yes&#10;  UseKeychain yes&#10;&#10;# Simulate teammate account (bestxn) on the same machine&#10;Host github-bestxn&#10;  HostName github.com&#10;  User git&#10;  IdentityFile ~/.ssh/id_ed25519_bestxn&#10;  IdentitiesOnly yes&#10;  AddKeysToAgent yes&#10;  UseKeychain yes" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/googleSites.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/googleSites.py" />
              <option name="originalContent" value="import argparse&#10;import html&#10;import re&#10;import subprocess&#10;import base64&#10;import os&#10;import time&#10;import urllib.request&#10;from dataclasses import dataclass&#10;from pathlib import Path&#10;from typing import Optional&#10;&#10;&#10;REPO_ROOT = Path(__file__).resolve().parent&#10;PAGES_DIR = REPO_ROOT / &quot;pages&quot;&#10;INDEX_HTML_PATH = REPO_ROOT / &quot;index.html&quot;&#10;DEFAULT_COMMIT_MESSAGE = &quot;Update privacy page&quot;&#10;&#10;# 固定页面模板：H1 永远为 &quot;Privacy Policy&quot;（居中、黑体、H1 大小）&#10;# 注意：页面标签 &lt;title&gt; 也固定为 Privacy Policy（App 名称不放在标题，以免被要求统一标题）。&#10;FALLBACK_TEMPLATE = &quot;&quot;&quot;&lt;html lang=\&quot;zh-CN\&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=\&quot;utf-8\&quot;&gt;\n  &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width,initial-scale=1\&quot;&gt;\n  &lt;title&gt;Privacy Policy&lt;/title&gt;\n  &lt;style&gt;\n    body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,\&quot;Helvetica Neue\&quot;,Arial;background:#f7f7fb;margin:0;padding:24px}}\n    .container{{max-width:860px;margin:28px auto;background:#fff;border-radius:10px;padding:28px;box-shadow:0 6px 22px rgba(20,20,30,0.06)}}\n    h1{{margin:0 0 18px;font-size:2rem;font-weight:700;text-align:center}}\n    .content{{line-height:1.7;color:#222;white-space:normal}}\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;main class=\&quot;container\&quot;&gt;\n    &lt;h1&gt;Privacy Policy&lt;/h1&gt;\n    &lt;div class=\&quot;content\&quot;&gt;\n{content}\n    &lt;/div&gt;\n  &lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;&quot;&quot;&#10;&#10;&#10;@dataclass&#10;class PageData:&#10;    title: str&#10;    # content can be plain text OR html fragment. use content_is_html to decide.&#10;    content: str&#10;    content_is_html: bool = False&#10;&#10;&#10;# 这里用一个 SSH Host alias（~/.ssh/config 里配置）来固定使用正确 key&#10;# 例如：Host github-common-hosts -&gt; HostName github.com + IdentityFile ~/.ssh/id_ed25519_common_hosts&#10;PREFERRED_GIT_SSH_HOST = (os.environ.get(&quot;PRIVACY_PAGES_SSH_HOST&quot;) or &quot;github-common-hosts&quot;).strip() or &quot;github-common-hosts&quot;&#10;DEFAULT_PAGES_SSH_KEY = Path(&quot;~/.ssh/id_ed25519_common_hosts&quot;).expanduser()&#10;&#10;&#10;def run(&#10;    cmd: list[str],&#10;    cwd: Optional[Path] = None,&#10;    env: Optional[dict[str, str]] = None,&#10;    check: bool = True,&#10;) -&gt; subprocess.CompletedProcess:&#10;    &quot;&quot;&quot;运行命令；失败就打印 stdout/stderr 并抛出。&quot;&quot;&quot;&#10;    merged_env = os.environ.copy()&#10;    if env:&#10;        merged_env.update(env)&#10;&#10;    p = subprocess.run(&#10;        cmd,&#10;        cwd=str(cwd) if cwd else None,&#10;        text=True,&#10;        capture_output=True,&#10;        env=merged_env,&#10;    )&#10;    if check and p.returncode != 0:&#10;        out = (p.stdout or &quot;&quot;).strip()&#10;        err = (p.stderr or &quot;&quot;).strip()&#10;        if out:&#10;            print(out)&#10;        if err:&#10;            print(err)&#10;        raise subprocess.CalledProcessError(p.returncode, cmd, output=p.stdout, stderr=p.stderr)&#10;    return p&#10;&#10;&#10;def _resolve_pages_ssh_key() -&gt; Optional[Path]:&#10;    &quot;&quot;&quot;Resolve which SSH key to use for git push.&#10;&#10;    Priority:&#10;      1) env PRIVACY_PAGES_SSH_KEY&#10;      2) DEFAULT_PAGES_SSH_KEY&#10;    &quot;&quot;&quot;&#10;    env_key = (os.environ.get(&quot;PRIVACY_PAGES_SSH_KEY&quot;) or &quot;&quot;).strip()&#10;    if env_key:&#10;        return Path(env_key).expanduser()&#10;    return DEFAULT_PAGES_SSH_KEY if DEFAULT_PAGES_SSH_KEY.exists() else None&#10;&#10;&#10;def _key_loaded_in_agent(key_path: Path) -&gt; bool:&#10;    try:&#10;        pub_path = Path(str(key_path) + &quot;.pub&quot;)&#10;        if not pub_path.exists():&#10;            return False&#10;        pub = pub_path.read_text(encoding=&quot;utf-8&quot;).strip()&#10;        if not pub:&#10;            return False&#10;        p = subprocess.run([&quot;ssh-add&quot;, &quot;-L&quot;], text=True, capture_output=True)&#10;        if p.returncode != 0:&#10;            return False&#10;        return pub.split()[1] in (p.stdout or &quot;&quot;)&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def _ensure_ssh_agent_has_key() -&gt; None:&#10;    &quot;&quot;&quot;Ensure ssh-agent is running and has the pages SSH key loaded.&#10;&#10;    On macOS, the best practice is to store the passphrase in Keychain once,&#10;    then use ssh-agent non-interactively forever.&#10;&#10;    One-time setup (manual):&#10;      ssh-add --apple-use-keychain ~/.ssh/id_ed25519_common_hosts&#10;    &quot;&quot;&quot;&#10;    key_path = _resolve_pages_ssh_key()&#10;    if not key_path:&#10;        return&#10;&#10;    # Start agent if needed&#10;    if not os.environ.get(&quot;SSH_AUTH_SOCK&quot;):&#10;        p = subprocess.run([&quot;ssh-agent&quot;, &quot;-s&quot;], text=True, capture_output=True)&#10;        out = p.stdout or &quot;&quot;&#10;        m_sock = re.search(r&quot;SSH_AUTH_SOCK=([^;]+);&quot;, out)&#10;        m_pid = re.search(r&quot;SSH_AGENT_PID=(\d+);&quot;, out)&#10;        if m_sock:&#10;            os.environ[&quot;SSH_AUTH_SOCK&quot;] = m_sock.group(1)&#10;        if m_pid:&#10;            os.environ[&quot;SSH_AGENT_PID&quot;] = m_pid.group(1)&#10;&#10;    # Already loaded?&#10;    if _key_loaded_in_agent(key_path):&#10;        return&#10;&#10;    # IMPORTANT: do not trigger an interactive passphrase prompt from a subprocess.&#10;    # If key isn't available yet, print a clear one-time setup instruction.&#10;    hint = (&#10;        &quot;\n⚠️ SSH key 未在 ssh-agent 中加载，且脚本不会在后台弹出口令输入。\n&quot;&#10;        &quot;请在终端手动执行一次（只需一次）：\n&quot;&#10;        &quot;  ssh-add --apple-use-keychain ~/.ssh/id_ed25519_common_hosts\n&quot;&#10;        &quot;之后再运行脚本即可做到全自动 push。\n&quot;&#10;    )&#10;    print(hint)&#10;&#10;&#10;def _git_env_for_pages_push() -&gt; dict[str, str]:&#10;    &quot;&quot;&quot;Force git/ssh to use the right identity and fail fast if key isn't loaded.&#10;&#10;    NOTE: We deliberately do not pass '-i' here to avoid triggering interactive passphrase prompts&#10;    from subprocess. Use ssh-agent + macOS Keychain for non-interactive pushes.&#10;    &quot;&quot;&quot;&#10;    _ensure_ssh_agent_has_key()&#10;&#10;    return {&#10;        &quot;GIT_SSH_COMMAND&quot;: (&#10;            &quot;ssh -o BatchMode=yes -o IdentitiesOnly=yes &quot;&#10;            &quot;-o StrictHostKeyChecking=accept-new &quot;&#10;            &quot;-o ControlMaster=auto -o ControlPersist=10m -o ControlPath=~/.ssh/cm-%r@%h:%p &quot;&#10;            &quot;-o Compression=no&quot;&#10;        )&#10;    }&#10;&#10;&#10;def _rewrite_remote_to_preferred_host(remote_url: str) -&gt; str:&#10;    &quot;&quot;&quot;Rewrite origin remote url to use our SSH host alias.&#10;&#10;    Example:&#10;      git@github.com:common-hosts/privacy-page.git  -&gt;  git@github-common-hosts:common-hosts/privacy-page.git&#10;    &quot;&quot;&quot;&#10;    u = (remote_url or &quot;&quot;).strip()&#10;    if not u:&#10;        return u&#10;&#10;    m = re.match(r&quot;^git@([^:]+):(.+)$&quot;, u)&#10;    if not m:&#10;        return u&#10;&#10;    host, rest = m.group(1), m.group(2)&#10;    if host == PREFERRED_GIT_SSH_HOST:&#10;        return u&#10;&#10;    if host == &quot;github.com&quot;:&#10;        return f&quot;git@{PREFERRED_GIT_SSH_HOST}:{rest}&quot;&#10;&#10;    return u&#10;&#10;&#10;def get_git_remote_url(remote: str = &quot;origin&quot;) -&gt; str:&#10;    try:&#10;        p = run([&quot;git&quot;, &quot;remote&quot;, &quot;get-url&quot;, remote], cwd=REPO_ROOT)&#10;        return (p.stdout or &quot;&quot;).strip()&#10;    except Exception:&#10;        return &quot;&quot;&#10;&#10;&#10;def _ensure_origin_uses_preferred_host() -&gt; None:&#10;    remote_url = get_git_remote_url(&quot;origin&quot;)&#10;    if not remote_url:&#10;        return&#10;    new_url = _rewrite_remote_to_preferred_host(remote_url)&#10;    if new_url != remote_url:&#10;        run([&quot;git&quot;, &quot;remote&quot;, &quot;set-url&quot;, &quot;origin&quot;, new_url], cwd=REPO_ROOT)&#10;&#10;&#10;def _ensure_git_identity() -&gt; None:&#10;    &quot;&quot;&quot;Prevent commit failures when user.name/user.email not configured.&quot;&quot;&quot;&#10;&#10;    def _cfg(key: str) -&gt; str:&#10;        p = subprocess.run(&#10;            [&quot;git&quot;, &quot;config&quot;, &quot;--get&quot;, key],&#10;            cwd=str(REPO_ROOT),&#10;            text=True,&#10;            capture_output=True,&#10;        )&#10;        return (p.stdout or &quot;&quot;).strip()&#10;&#10;    name = _cfg(&quot;user.name&quot;)&#10;    email = _cfg(&quot;user.email&quot;)&#10;    if not name:&#10;        run([&quot;git&quot;, &quot;config&quot;, &quot;user.name&quot;, &quot;privacy-bot&quot;], cwd=REPO_ROOT)&#10;    if not email:&#10;        run(&#10;            [&quot;git&quot;, &quot;config&quot;, &quot;user.email&quot;, &quot;privacy-bot@users.noreply.github.com&quot;],&#10;            cwd=REPO_ROOT,&#10;        )&#10;&#10;&#10;def get_repo_slug_from_remote(remote_url: str) -&gt; str:&#10;    &quot;&quot;&quot;Extract owner/repo from git remote url.&#10;&#10;    Supported:&#10;      - SSH: git@github.com:owner/repo.git&#10;      - HTTPS: https://github.com/owner/repo.git&#10;    &quot;&quot;&quot;&#10;    u = (remote_url or &quot;&quot;).strip()&#10;    if not u:&#10;        raise ValueError(f&quot;Unsupported remote url: {remote_url!r}&quot;)&#10;&#10;    # SSH&#10;    m = re.match(r&quot;^git@[^:]+:([^/]+)/(.+?)(?:\.git)?$&quot;, u)&#10;    if m:&#10;        return f&quot;{m.group(1)}/{m.group(2)}&quot;&#10;&#10;    # HTTPS&#10;    m = re.match(r&quot;^https?://[^/]+/([^/]+)/(.+?)(?:\.git)?/?$&quot;, u)&#10;    if m:&#10;        return f&quot;{m.group(1)}/{m.group(2)}&quot;&#10;&#10;    raise ValueError(f&quot;Unsupported remote url: {remote_url!r}&quot;)&#10;&#10;&#10;def github_pages_base_url(repo_slug: str) -&gt; str:&#10;    owner, repo = repo_slug.split(&quot;/&quot;, 1)&#10;    return f&quot;https://{owner}.github.io/{repo}/&quot;&#10;&#10;&#10;def slugify(s: str) -&gt; str:&#10;    &quot;&quot;&quot;Generate safe path slug for GitHub Pages URL.&quot;&quot;&quot;&#10;    s = (s or &quot;&quot;).strip().lower()&#10;    s = re.sub(r&quot;[\s_]+&quot;, &quot;-&quot;, s)&#10;    s = re.sub(r&quot;[^a-z0-9\-]+&quot;, &quot;-&quot;, s)&#10;    s = re.sub(r&quot;-+&quot;, &quot;-&quot;, s).strip(&quot;-&quot;)&#10;    return s or &quot;privacy-policy&quot;&#10;&#10;&#10;def escape_and_preserve_newlines_as_html(text: str) -&gt; str:&#10;    &quot;&quot;&quot;Plain text -&gt; safe HTML, keeping line breaks and indentation for nicer display.&quot;&quot;&quot;&#10;    safe = html.escape(text or &quot;&quot;)&#10;    safe = safe.replace(&quot;  &quot;, &quot;&amp;nbsp;&amp;nbsp;&quot;)&#10;    safe = safe.replace(&quot;\r\n&quot;, &quot;\n&quot;).replace(&quot;\r&quot;, &quot;\n&quot;)&#10;    safe = safe.replace(&quot;\n&quot;, &quot;&lt;br&gt;\n&quot;)&#10;    return safe&#10;&#10;&#10;def encode_id_to_base64_letters(raw_id: str) -&gt; str:&#10;    &quot;&quot;&quot;把编号编码成 base64url 形式（只包含字母/数字/连字符/下划线），更短且可用于 URL 路径。&quot;&quot;&quot;&#10;    raw = (raw_id or &quot;&quot;).strip()&#10;    if not raw:&#10;        return &quot;&quot;&#10;    b = raw.encode(&quot;utf-8&quot;)&#10;    return base64.urlsafe_b64encode(b).decode(&quot;ascii&quot;).rstrip(&quot;=&quot;)&#10;&#10;&#10;def strip_leading_privacy_policy(text: str) -&gt; str:&#10;    &quot;&quot;&quot;去掉正文最前面的 'Privacy Policy' + 空行，避免页面出现重复标题。&quot;&quot;&quot;&#10;    if not text:&#10;        return &quot;&quot;&#10;    t = text.lstrip(&quot;\ufeff\n\r\t &quot;)&#10;    if re.match(r&quot;(?is)^privacy\s*policy\s*(\n|\r\n)\s*(\n|\r\n)&quot;, t):&#10;        t = re.sub(r&quot;(?is)^privacy\s*policy\s*(\n|\r\n)\s*(\n|\r\n)&quot;, &quot;&quot;, t, count=1)&#10;    return t&#10;&#10;&#10;def render_html(page: PageData) -&gt; str:&#10;    content_source = page.content&#10;    if not page.content_is_html:&#10;        content_source = strip_leading_privacy_policy(content_source)&#10;&#10;    content_html = content_source if page.content_is_html else escape_and_preserve_newlines_as_html(content_source)&#10;    return FALLBACK_TEMPLATE.format(content=content_html)&#10;&#10;&#10;def write_privacy_page(page: PageData, page_slug: str) -&gt; Path:&#10;    &quot;&quot;&quot;Write to pages/&lt;slug&gt;/index.html and return the written path.&quot;&quot;&quot;&#10;    page_dir = PAGES_DIR / page_slug&#10;    page_dir.mkdir(parents=True, exist_ok=True)&#10;    out_path = page_dir / &quot;index.html&quot;&#10;    out_path.write_text(render_html(page), encoding=&quot;utf-8&quot;)&#10;    return out_path&#10;&#10;&#10;def write_root_landing(latest_url: str) -&gt; None:&#10;    landing = (&#10;        f&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;0; url={html.escape(latest_url)}\&quot;&gt;&lt;/head&gt;\n&quot;&#10;        f&quot;&lt;body&gt;Redirecting to &lt;a href=\&quot;{html.escape(latest_url)}\&quot;&gt;{html.escape(latest_url)}&lt;/a&gt;...&lt;/body&gt;&lt;/html&gt;\n&quot;&#10;    )&#10;    INDEX_HTML_PATH.write_text(landing, encoding=&quot;utf-8&quot;)&#10;&#10;&#10;def read_content_from_file(path: Path) -&gt; str:&#10;    return path.read_text(encoding=&quot;utf-8&quot;)&#10;&#10;&#10;def git_commit_push(commit_message: str) -&gt; None:&#10;    &quot;&quot;&quot;git add/commit/push; if nothing to commit, skip commit step.&quot;&quot;&quot;&#10;    _ensure_origin_uses_preferred_host()&#10;    _ensure_git_identity()&#10;&#10;    run([&quot;git&quot;, &quot;add&quot;, &quot;-A&quot;], cwd=REPO_ROOT)&#10;&#10;    st = run([&quot;git&quot;, &quot;status&quot;, &quot;--porcelain&quot;], cwd=REPO_ROOT, check=False)&#10;    if not (st.stdout or &quot;&quot;).strip():&#10;        print(&quot;ℹ️ 没有文件变更，跳过 commit。&quot;)&#10;    else:&#10;        run([&quot;git&quot;, &quot;commit&quot;, &quot;-m&quot;, commit_message], cwd=REPO_ROOT)&#10;&#10;    env = _git_env_for_pages_push()&#10;    b = run([&quot;git&quot;, &quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;], cwd=REPO_ROOT)&#10;    branch = (b.stdout or &quot;main&quot;).strip() or &quot;main&quot;&#10;&#10;    # Push using the preferred host alias (origin should already be rewritten, but keep this robust)&#10;    try:&#10;        run([&quot;git&quot;, &quot;push&quot;, &quot;origin&quot;, branch], cwd=REPO_ROOT, env=env)&#10;    except subprocess.CalledProcessError:&#10;        # Print debug info and retry once with porcelain&#10;        try:&#10;            print(&quot;--- git remote -v ---&quot;)&#10;            rp = subprocess.run([&quot;git&quot;, &quot;remote&quot;, &quot;-v&quot;], cwd=str(REPO_ROOT), text=True, capture_output=True)&#10;            print((rp.stdout or &quot;&quot;).strip())&#10;        except Exception:&#10;            pass&#10;        run([&quot;git&quot;, &quot;push&quot;, &quot;--porcelain&quot;, &quot;--no-verify&quot;, &quot;origin&quot;, branch], cwd=REPO_ROOT, env=env)&#10;&#10;&#10;def wait_until_url_ready(url: str, timeout_seconds: int = 120, interval_seconds: float = 3.0) -&gt; bool:&#10;    &quot;&quot;&quot;Poll the published GitHub Pages URL until it returns HTTP 200。&#10;&#10;    GitHub Pages often has a small build/deploy delay. This prevents the&#10;    &quot;new page 404, old page works&quot; confusion.&#10;    &quot;&quot;&quot;&#10;    end = time.time() + timeout_seconds&#10;    last_err = &quot;&quot;&#10;    while time.time() &lt; end:&#10;        try:&#10;            req = urllib.request.Request(url, headers={&quot;User-Agent&quot;: &quot;Mozilla/5.0&quot;})&#10;            with urllib.request.urlopen(req, timeout=20) as resp:&#10;                if getattr(resp, &quot;status&quot;, 200) == 200:&#10;                    return True&#10;        except Exception as e:&#10;            last_err = str(e)&#10;        time.sleep(interval_seconds)&#10;&#10;    if last_err:&#10;        print(f&quot;⚠️ 页面在 {timeout_seconds}s 内仍不可访问（可能还在部署中）：{last_err}&quot;)&#10;    else:&#10;        print(f&quot;⚠️ 页面在 {timeout_seconds}s 内仍不可访问（可能还在部署中）。&quot;)&#10;    return False&#10;&#10;&#10;# --- Clipboard helpers (macOS) ---&#10;def copy_to_clipboard_macos(text: str) -&gt; bool:&#10;    &quot;&quot;&quot;Copy text to macOS clipboard using pbcopy.&quot;&quot;&quot;&#10;    if not text:&#10;        return False&#10;    try:&#10;        subprocess.run([&quot;pbcopy&quot;], input=text.encode(&quot;utf-8&quot;), check=True)&#10;        return True&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def show_macos_toast(message: str, seconds: int = 3) -&gt; None:&#10;    &quot;&quot;&quot;Best-effort toast via AppleScript (no hard failure if blocked).&quot;&quot;&quot;&#10;    msg = (message or &quot;&quot;).replace('&quot;', &quot;\\\&quot;&quot;)&#10;    try:&#10;        subprocess.run(&#10;            [&quot;osascript&quot;, &quot;-e&quot;, f'display notification &quot;{msg}&quot; with title &quot;PrivacyTools&quot;'],&#10;            check=False,&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser(description=&quot;Publish per-app privacy page to GitHub Pages (no overwrite).&quot;)&#10;    parser.add_argument(&quot;--title&quot;, required=True, help=&quot;App name (for logging only; page H1/title are fixed)&quot;)&#10;    parser.add_argument(&quot;--content&quot;, help=&quot;Page content (plain text).&quot;)&#10;    parser.add_argument(&quot;--content-file&quot;, help=&quot;Read content from a text file instead of --content&quot;)&#10;    parser.add_argument(&quot;--content-is-html&quot;, action=&quot;store_true&quot;, help=&quot;Treat content as HTML (no escaping).&quot;)&#10;    parser.add_argument(&quot;--slug&quot;, help=&quot;Optional custom slug; default: encoded_id + '-' + slugify(title)&quot;)&#10;    parser.add_argument(&quot;--id&quot;, help=&quot;Optional raw ID (e.g. IGT1128). If provided, will be encoded into slug prefix.&quot;)&#10;    parser.add_argument(&quot;--commit-message&quot;, default=DEFAULT_COMMIT_MESSAGE, help=&quot;Git commit message&quot;)&#10;    parser.add_argument(&quot;--no-push&quot;, action=&quot;store_true&quot;, help=&quot;Only write files, do not commit/push&quot;)&#10;    parser.add_argument(&#10;        &quot;--no-wait&quot;,&#10;        action=&quot;store_true&quot;,&#10;        help=&quot;Do not wait/poll for GitHub Pages deployment (faster; URL may 404 for a bit).&quot;,&#10;    )&#10;&#10;    args = parser.parse_args()&#10;&#10;    if args.content_file:&#10;        content = read_content_from_file(Path(args.content_file))&#10;    else:&#10;        content = args.content or &quot;&quot;&#10;&#10;    # Build slug&#10;    if args.slug:&#10;        page_slug = args.slug&#10;    else:&#10;        id_prefix = encode_id_to_base64_letters(args.id or &quot;&quot;)&#10;        if id_prefix:&#10;            page_slug = f&quot;{id_prefix}-{slugify(args.title)}&quot;&#10;        else:&#10;            page_slug = slugify(args.title)&#10;&#10;    page = PageData(title=args.title, content=content, content_is_html=args.content_is_html)&#10;    out_path = write_privacy_page(page, page_slug)&#10;&#10;    repo_slug = get_repo_slug_from_remote(get_git_remote_url(&quot;origin&quot;))&#10;    page_url = github_pages_base_url(repo_slug) + f&quot;pages/{page_slug}/&quot;&#10;&#10;    # optional: write root index.html redirect for convenience&#10;    try:&#10;        write_root_landing(page_url)&#10;    except Exception:&#10;        pass&#10;&#10;    print(f&quot;✅ Wrote privacy page: {out_path}&quot;)&#10;    print(f&quot; Page URL: {page_url}&quot;)&#10;&#10;    if args.no_push:&#10;        print(&quot;ℹ️ --no-push used. Skipping git commit/push.&quot;)&#10;        return&#10;&#10;    try:&#10;        git_commit_push(args.commit_message)&#10;&#10;        # give user a quick clipboard copy for convenience&#10;        if copy_to_clipboard_macos(page_url):&#10;            show_macos_toast(&quot;发布链接已复制&quot;, seconds=3)&#10;&#10;        if not args.no_wait:&#10;            print(&quot;⏳ 等待 GitHub Pages 部署生效...&quot;)&#10;            if wait_until_url_ready(page_url, timeout_seconds=180, interval_seconds=4.0):&#10;                print(&quot;✅ 页面已可访问。&quot;)&#10;            else:&#10;                print(&quot;ℹ️ 可能需要再等一会儿再刷新浏览器（GitHub Pages 有部署延迟）。&quot;)&#10;&#10;    except subprocess.CalledProcessError as e:&#10;        err = (e.stderr or &quot;&quot;).strip()&#10;        out = (e.output or &quot;&quot;).strip()&#10;        if out:&#10;            print(out)&#10;        if err:&#10;            print(err)&#10;        raise SystemExit(f&quot;命令失败: {e.cmd} (exit {e.returncode})&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="import argparse&#10;import html&#10;import re&#10;import subprocess&#10;import base64&#10;import os&#10;import time&#10;import urllib.request&#10;from dataclasses import dataclass&#10;from pathlib import Path&#10;from typing import Optional&#10;&#10;&#10;REPO_ROOT = Path(__file__).resolve().parent&#10;PAGES_DIR = REPO_ROOT / &quot;pages&quot;&#10;INDEX_HTML_PATH = REPO_ROOT / &quot;index.html&quot;&#10;DEFAULT_COMMIT_MESSAGE = &quot;Update privacy page&quot;&#10;&#10;# 固定页面模板：H1 永远为 &quot;Privacy Policy&quot;（居中、黑体、H1 大小）&#10;# 注意：页面标签 &lt;title&gt; 也固定为 Privacy Policy（App 名称不放在标题，以免被要求统一标题）。&#10;FALLBACK_TEMPLATE = &quot;&quot;&quot;&lt;html lang=\&quot;zh-CN\&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=\&quot;utf-8\&quot;&gt;\n  &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width,initial-scale=1\&quot;&gt;\n  &lt;title&gt;Privacy Policy&lt;/title&gt;\n  &lt;style&gt;\n    body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,\&quot;Helvetica Neue\&quot;,Arial;background:#f7f7fb;margin:0;padding:24px}}\n    .container{{max-width:860px;margin:28px auto;background:#fff;border-radius:10px;padding:28px;box-shadow:0 6px 22px rgba(20,20,30,0.06)}}\n    h1{{margin:0 0 18px;font-size:2rem;font-weight:700;text-align:center}}\n    .content{{line-height:1.7;color:#222;white-space:normal}}\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;main class=\&quot;container\&quot;&gt;\n    &lt;h1&gt;Privacy Policy&lt;/h1&gt;\n    &lt;div class=\&quot;content\&quot;&gt;\n{content}\n    &lt;/div&gt;\n  &lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;&quot;&quot;&#10;&#10;&#10;@dataclass&#10;class PageData:&#10;    title: str&#10;    # content can be plain text OR html fragment. use content_is_html to decide.&#10;    content: str&#10;    content_is_html: bool = False&#10;&#10;&#10;# 这里用一个 SSH Host alias（~/.ssh/config 里配置）来固定使用正确 key&#10;# 例如：Host github-common-hosts -&gt; HostName github.com + IdentityFile ~/.ssh/id_ed25519_common_hosts&#10;PREFERRED_GIT_SSH_HOST = (os.environ.get(&quot;PRIVACY_PAGES_SSH_HOST&quot;) or &quot;github-common-hosts&quot;).strip() or &quot;github-common-hosts&quot;&#10;DEFAULT_PAGES_SSH_KEY = Path(os.environ.get(&quot;PRIVACY_PAGES_SSH_KEY&quot;, &quot;~/.ssh/id_ed25519_common_hosts&quot;)).expanduser()&#10;&#10;&#10;def run(&#10;    cmd: list[str],&#10;    cwd: Optional[Path] = None,&#10;    env: Optional[dict[str, str]] = None,&#10;    check: bool = True,&#10;) -&gt; subprocess.CompletedProcess:&#10;    &quot;&quot;&quot;运行命令；失败就打印 stdout/stderr 并抛出。&quot;&quot;&quot;&#10;    merged_env = os.environ.copy()&#10;    if env:&#10;        merged_env.update(env)&#10;&#10;    p = subprocess.run(&#10;        cmd,&#10;        cwd=str(cwd) if cwd else None,&#10;        text=True,&#10;        capture_output=True,&#10;        env=merged_env,&#10;    )&#10;    if check and p.returncode != 0:&#10;        out = (p.stdout or &quot;&quot;).strip()&#10;        err = (p.stderr or &quot;&quot;).strip()&#10;        if out:&#10;            print(out)&#10;        if err:&#10;            print(err)&#10;        raise subprocess.CalledProcessError(p.returncode, cmd, output=p.stdout, stderr=p.stderr)&#10;    return p&#10;&#10;&#10;def _resolve_pages_ssh_key() -&gt; Optional[Path]:&#10;    &quot;&quot;&quot;Resolve which SSH key to use for git push.&quot;&quot;&quot;&#10;    return DEFAULT_PAGES_SSH_KEY if DEFAULT_PAGES_SSH_KEY.exists() else None&#10;&#10;&#10;def _key_loaded_in_agent(key_path: Path) -&gt; bool:&#10;    try:&#10;        pub_path = Path(str(key_path) + &quot;.pub&quot;)&#10;        if not pub_path.exists():&#10;            return False&#10;        pub = pub_path.read_text(encoding=&quot;utf-8&quot;).strip()&#10;        if not pub:&#10;            return False&#10;        p = subprocess.run([&quot;ssh-add&quot;, &quot;-L&quot;], text=True, capture_output=True)&#10;        if p.returncode != 0:&#10;            return False&#10;        # compare pub key body part&#10;        parts = pub.split()&#10;        return len(parts) &gt;= 2 and parts[1] in (p.stdout or &quot;&quot;)&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def _ensure_ssh_agent_has_key() -&gt; None:&#10;    &quot;&quot;&quot;Ensure ssh-agent exists and has the pages SSH key loaded.&#10;&#10;    We DO NOT auto-run ssh-add here (it may prompt for passphrase, which would hang&#10;    when running from scripts). Instead we print a one-time setup hint.&#10;    &quot;&quot;&quot;&#10;    key_path = _resolve_pages_ssh_key()&#10;    if not key_path:&#10;        return&#10;&#10;    # If already loaded, do nothing&#10;    if _key_loaded_in_agent(key_path):&#10;        return&#10;&#10;    print(&#10;        &quot;\n⚠️ 当前环境的 ssh-agent 里还没有加载 GitHub Pages 的 SSH key，脚本将无法自动 push。\n&quot;&#10;        &quot;请在终端手动执行一次（只需一次）：\n&quot;&#10;        f&quot;  ssh-add --apple-use-keychain {key_path}\n&quot;&#10;        &quot;输入 passphrase 后，会保存到 Keychain，之后运行脚本就不会再提示。\n&quot;&#10;    )&#10;&#10;&#10;def _git_env_for_pages_push() -&gt; dict[str, str]:&#10;    &quot;&quot;&quot;Force git/ssh to use the right identity non-interactively.&quot;&quot;&quot;&#10;    _ensure_ssh_agent_has_key()&#10;    # BatchMode=yes =&gt; never prompt for passphrase in subprocess (fail fast with clear error)&#10;    return {&#10;        &quot;GIT_SSH_COMMAND&quot;: (&#10;            &quot;ssh -o BatchMode=yes -o IdentitiesOnly=yes &quot;&#10;            &quot;-o StrictHostKeyChecking=accept-new &quot;&#10;            &quot;-o ControlMaster=auto -o ControlPersist=10m -o ControlPath=~/.ssh/cm-%r@%h:%p&quot;&#10;        ),&#10;        # speedups&#10;        &quot;GIT_PROTOCOL&quot;: &quot;version=2&quot;,&#10;    }&#10;&#10;&#10;def _rewrite_remote_to_preferred_host(remote_url: str) -&gt; str:&#10;    &quot;&quot;&quot;Rewrite origin remote url to use our SSH host alias.&#10;&#10;    Example:&#10;      git@github.com:common-hosts/privacy-page.git  -&gt;  git@github-common-hosts:common-hosts/privacy-page.git&#10;    &quot;&quot;&quot;&#10;    u = (remote_url or &quot;&quot;).strip()&#10;    if not u:&#10;        return u&#10;&#10;    m = re.match(r&quot;^git@([^:]+):(.+)$&quot;, u)&#10;    if not m:&#10;        return u&#10;&#10;    host, rest = m.group(1), m.group(2)&#10;    if host == PREFERRED_GIT_SSH_HOST:&#10;        return u&#10;&#10;    if host == &quot;github.com&quot;:&#10;        return f&quot;git@{PREFERRED_GIT_SSH_HOST}:{rest}&quot;&#10;&#10;    return u&#10;&#10;&#10;def get_git_remote_url(remote: str = &quot;origin&quot;) -&gt; str:&#10;    try:&#10;        p = run([&quot;git&quot;, &quot;remote&quot;, &quot;get-url&quot;, remote], cwd=REPO_ROOT)&#10;        return (p.stdout or &quot;&quot;).strip()&#10;    except Exception:&#10;        return &quot;&quot;&#10;&#10;&#10;def _ensure_origin_uses_preferred_host() -&gt; None:&#10;    remote_url = get_git_remote_url(&quot;origin&quot;)&#10;    if not remote_url:&#10;        return&#10;    new_url = _rewrite_remote_to_preferred_host(remote_url)&#10;    if new_url != remote_url:&#10;        run([&quot;git&quot;, &quot;remote&quot;, &quot;set-url&quot;, &quot;origin&quot;, new_url], cwd=REPO_ROOT)&#10;&#10;&#10;def _ensure_git_identity() -&gt; None:&#10;    &quot;&quot;&quot;Prevent commit failures when user.name/user.email not configured.&quot;&quot;&quot;&#10;&#10;    def _cfg(key: str) -&gt; str:&#10;        p = subprocess.run(&#10;            [&quot;git&quot;, &quot;config&quot;, &quot;--get&quot;, key],&#10;            cwd=str(REPO_ROOT),&#10;            text=True,&#10;            capture_output=True,&#10;        )&#10;        return (p.stdout or &quot;&quot;).strip()&#10;&#10;    name = _cfg(&quot;user.name&quot;)&#10;    email = _cfg(&quot;user.email&quot;)&#10;    if not name:&#10;        run([&quot;git&quot;, &quot;config&quot;, &quot;user.name&quot;, &quot;privacy-bot&quot;], cwd=REPO_ROOT)&#10;    if not email:&#10;        run(&#10;            [&quot;git&quot;, &quot;config&quot;, &quot;user.email&quot;, &quot;privacy-bot@users.noreply.github.com&quot;],&#10;            cwd=REPO_ROOT,&#10;        )&#10;&#10;&#10;def get_repo_slug_from_remote(remote_url: str) -&gt; str:&#10;    &quot;&quot;&quot;Extract owner/repo from git remote url.&#10;&#10;    Supported:&#10;      - SSH: git@github.com:owner/repo.git&#10;      - HTTPS: https://github.com/owner/repo.git&#10;    &quot;&quot;&quot;&#10;    u = (remote_url or &quot;&quot;).strip()&#10;    if not u:&#10;        raise ValueError(f&quot;Unsupported remote url: {remote_url!r}&quot;)&#10;&#10;    # SSH&#10;    m = re.match(r&quot;^git@[^:]+:([^/]+)/(.+?)(?:\.git)?$&quot;, u)&#10;    if m:&#10;        return f&quot;{m.group(1)}/{m.group(2)}&quot;&#10;&#10;    # HTTPS&#10;    m = re.match(r&quot;^https?://[^/]+/([^/]+)/(.+?)(?:\.git)?/?$&quot;, u)&#10;    if m:&#10;        return f&quot;{m.group(1)}/{m.group(2)}&quot;&#10;&#10;    raise ValueError(f&quot;Unsupported remote url: {remote_url!r}&quot;)&#10;&#10;&#10;def github_pages_base_url(repo_slug: str) -&gt; str:&#10;    owner, repo = repo_slug.split(&quot;/&quot;, 1)&#10;    return f&quot;https://{owner}.github.io/{repo}/&quot;&#10;&#10;&#10;def slugify(s: str) -&gt; str:&#10;    &quot;&quot;&quot;Generate safe path slug for GitHub Pages URL.&quot;&quot;&quot;&#10;    s = (s or &quot;&quot;).strip().lower()&#10;    s = re.sub(r&quot;[\s_]+&quot;, &quot;-&quot;, s)&#10;    s = re.sub(r&quot;[^a-z0-9\-]+&quot;, &quot;-&quot;, s)&#10;    s = re.sub(r&quot;-+&quot;, &quot;-&quot;, s).strip(&quot;-&quot;)&#10;    return s or &quot;privacy-policy&quot;&#10;&#10;&#10;def escape_and_preserve_newlines_as_html(text: str) -&gt; str:&#10;    &quot;&quot;&quot;Plain text -&gt; safe HTML, keeping line breaks and indentation for nicer display.&quot;&quot;&quot;&#10;    safe = html.escape(text or &quot;&quot;)&#10;    safe = safe.replace(&quot;  &quot;, &quot;&amp;nbsp;&amp;nbsp;&quot;)&#10;    safe = safe.replace(&quot;\r\n&quot;, &quot;\n&quot;).replace(&quot;\r&quot;, &quot;\n&quot;)&#10;    safe = safe.replace(&quot;\n&quot;, &quot;&lt;br&gt;\n&quot;)&#10;    return safe&#10;&#10;&#10;def encode_id_to_base64_letters(raw_id: str) -&gt; str:&#10;    &quot;&quot;&quot;把编号编码成 base64url 形式（只包含字母/数字/连字符/下划线），更短且可用于 URL 路径。&quot;&quot;&quot;&#10;    raw = (raw_id or &quot;&quot;).strip()&#10;    if not raw:&#10;        return &quot;&quot;&#10;    b = raw.encode(&quot;utf-8&quot;)&#10;    return base64.urlsafe_b64encode(b).decode(&quot;ascii&quot;).rstrip(&quot;=&quot;)&#10;&#10;&#10;def strip_leading_privacy_policy(text: str) -&gt; str:&#10;    &quot;&quot;&quot;去掉正文最前面的 'Privacy Policy' + 空行，避免页面出现重复标题。&quot;&quot;&quot;&#10;    if not text:&#10;        return &quot;&quot;&#10;    t = text.lstrip(&quot;\ufeff\n\r\t &quot;)&#10;    if re.match(r&quot;(?is)^privacy\s*policy\s*(\n|\r\n)\s*(\n|\r\n)&quot;, t):&#10;        t = re.sub(r&quot;(?is)^privacy\s*policy\s*(\n|\r\n)\s*(\n|\r\n)&quot;, &quot;&quot;, t, count=1)&#10;    return t&#10;&#10;&#10;def render_html(page: PageData) -&gt; str:&#10;    content_source = page.content&#10;    if not page.content_is_html:&#10;        content_source = strip_leading_privacy_policy(content_source)&#10;&#10;    content_html = content_source if page.content_is_html else escape_and_preserve_newlines_as_html(content_source)&#10;    return FALLBACK_TEMPLATE.format(content=content_html)&#10;&#10;&#10;def write_privacy_page(page: PageData, page_slug: str) -&gt; Path:&#10;    &quot;&quot;&quot;Write to pages/&lt;slug&gt;/index.html and return the written path.&quot;&quot;&quot;&#10;    page_dir = PAGES_DIR / page_slug&#10;    page_dir.mkdir(parents=True, exist_ok=True)&#10;    out_path = page_dir / &quot;index.html&quot;&#10;    out_path.write_text(render_html(page), encoding=&quot;utf-8&quot;)&#10;    return out_path&#10;&#10;&#10;def write_root_landing(latest_url: str) -&gt; None:&#10;    landing = (&#10;        f&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;0; url={html.escape(latest_url)}\&quot;&gt;&lt;/head&gt;\n&quot;&#10;        f&quot;&lt;body&gt;Redirecting to &lt;a href=\&quot;{html.escape(latest_url)}\&quot;&gt;{html.escape(latest_url)}&lt;/a&gt;...&lt;/body&gt;&lt;/html&gt;\n&quot;&#10;    )&#10;    INDEX_HTML_PATH.write_text(landing, encoding=&quot;utf-8&quot;)&#10;&#10;&#10;def read_content_from_file(path: Path) -&gt; str:&#10;    return path.read_text(encoding=&quot;utf-8&quot;)&#10;&#10;&#10;def git_commit_push(commit_message: str) -&gt; None:&#10;    &quot;&quot;&quot;git add/commit/push; if nothing to commit, still push to be safe.&quot;&quot;&quot;&#10;    _ensure_origin_uses_preferred_host()&#10;    _ensure_git_identity()&#10;&#10;    run([&quot;git&quot;, &quot;add&quot;, &quot;-A&quot;], cwd=REPO_ROOT)&#10;&#10;    st = run([&quot;git&quot;, &quot;status&quot;, &quot;--porcelain&quot;], cwd=REPO_ROOT, check=False)&#10;    if not (st.stdout or &quot;&quot;).strip():&#10;        print(&quot;ℹ️ 没有文件变更，跳过 commit。&quot;)&#10;    else:&#10;        run([&quot;git&quot;, &quot;commit&quot;, &quot;-m&quot;, commit_message], cwd=REPO_ROOT)&#10;&#10;    env = _git_env_for_pages_push()&#10;    b = run([&quot;git&quot;, &quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;], cwd=REPO_ROOT)&#10;    branch = (b.stdout or &quot;main&quot;).strip() or &quot;main&quot;&#10;&#10;    # Push using origin (already rewritten to preferred host).&#10;    run([&quot;git&quot;, &quot;push&quot;, &quot;origin&quot;, branch], cwd=REPO_ROOT, env=env)&#10;&#10;&#10;def wait_until_url_ready(url: str, timeout_seconds: int = 120, interval_seconds: float = 3.0) -&gt; bool:&#10;    &quot;&quot;&quot;Poll the published GitHub Pages URL until it returns HTTP 200。&#10;&#10;    GitHub Pages often has a small build/deploy delay. This prevents the&#10;    &quot;new page 404, old page works&quot; confusion.&#10;    &quot;&quot;&quot;&#10;    end = time.time() + timeout_seconds&#10;    last_err = &quot;&quot;&#10;    while time.time() &lt; end:&#10;        try:&#10;            req = urllib.request.Request(url, headers={&quot;User-Agent&quot;: &quot;Mozilla/5.0&quot;})&#10;            with urllib.request.urlopen(req, timeout=20) as resp:&#10;                if getattr(resp, &quot;status&quot;, 200) == 200:&#10;                    return True&#10;        except Exception as e:&#10;            last_err = str(e)&#10;        time.sleep(interval_seconds)&#10;&#10;    if last_err:&#10;        print(f&quot;⚠️ 页面在 {timeout_seconds}s 内仍不可访问（可能还在部署中）：{last_err}&quot;)&#10;    else:&#10;        print(f&quot;⚠️ 页面在 {timeout_seconds}s 内仍不可访问（可能还在部署中）。&quot;)&#10;    return False&#10;&#10;&#10;# --- Clipboard helpers (macOS) ---&#10;def copy_to_clipboard_macos(text: str) -&gt; bool:&#10;    &quot;&quot;&quot;Copy text to macOS clipboard using pbcopy.&quot;&quot;&quot;&#10;    if not text:&#10;        return False&#10;    try:&#10;        subprocess.run([&quot;pbcopy&quot;], input=text.encode(&quot;utf-8&quot;), check=True)&#10;        return True&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def show_macos_toast(message: str, seconds: int = 3) -&gt; None:&#10;    &quot;&quot;&quot;Best-effort toast via AppleScript (no hard failure if blocked).&quot;&quot;&quot;&#10;    msg = (message or &quot;&quot;).replace('&quot;', &quot;\\\&quot;&quot;)&#10;    try:&#10;        subprocess.run(&#10;            [&quot;osascript&quot;, &quot;-e&quot;, f'display notification &quot;{msg}&quot; with title &quot;PrivacyTools&quot;'],&#10;            check=False,&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser(description=&quot;Publish per-app privacy page to GitHub Pages (no overwrite).&quot;)&#10;    parser.add_argument(&quot;--title&quot;, required=True, help=&quot;App name (for logging only; page H1/title are fixed)&quot;)&#10;    parser.add_argument(&quot;--content&quot;, help=&quot;Page content (plain text).&quot;)&#10;    parser.add_argument(&quot;--content-file&quot;, help=&quot;Read content from a text file instead of --content&quot;)&#10;    parser.add_argument(&quot;--content-is-html&quot;, action=&quot;store_true&quot;, help=&quot;Treat content as HTML (no escaping).&quot;)&#10;    parser.add_argument(&quot;--slug&quot;, help=&quot;Optional custom slug; default: encoded_id + '-' + slugify(title)&quot;)&#10;    parser.add_argument(&quot;--id&quot;, help=&quot;Optional raw ID (e.g. IGT1128). If provided, will be encoded into slug prefix.&quot;)&#10;    parser.add_argument(&quot;--commit-message&quot;, default=DEFAULT_COMMIT_MESSAGE, help=&quot;Git commit message&quot;)&#10;    parser.add_argument(&quot;--no-push&quot;, action=&quot;store_true&quot;, help=&quot;Only write files, do not commit/push&quot;)&#10;    parser.add_argument(&#10;        &quot;--no-wait&quot;,&#10;        action=&quot;store_true&quot;,&#10;        help=&quot;Do not wait/poll for GitHub Pages deployment (faster; URL may 404 for a bit).&quot;,&#10;    )&#10;&#10;    args = parser.parse_args()&#10;&#10;    if args.content_file:&#10;        content = read_content_from_file(Path(args.content_file))&#10;    else:&#10;        content = args.content or &quot;&quot;&#10;&#10;    # Build slug&#10;    if args.slug:&#10;        page_slug = args.slug&#10;    else:&#10;        id_prefix = encode_id_to_base64_letters(args.id or &quot;&quot;)&#10;        if id_prefix:&#10;            page_slug = f&quot;{id_prefix}-{slugify(args.title)}&quot;&#10;        else:&#10;            page_slug = slugify(args.title)&#10;&#10;    page = PageData(title=args.title, content=content, content_is_html=args.content_is_html)&#10;    out_path = write_privacy_page(page, page_slug)&#10;&#10;    repo_slug = get_repo_slug_from_remote(get_git_remote_url(&quot;origin&quot;))&#10;    page_url = github_pages_base_url(repo_slug) + f&quot;pages/{page_slug}/&quot;&#10;&#10;    # optional: write root index.html redirect for convenience&#10;    try:&#10;        write_root_landing(page_url)&#10;    except Exception:&#10;        pass&#10;&#10;    print(f&quot;✅ Wrote privacy page: {out_path}&quot;)&#10;    print(f&quot; Page URL: {page_url}&quot;)&#10;&#10;    if args.no_push:&#10;        print(&quot;ℹ️ --no-push used. Skipping git commit/push.&quot;)&#10;        return&#10;&#10;    try:&#10;        git_commit_push(args.commit_message)&#10;&#10;        # give user a quick clipboard copy for convenience&#10;        if copy_to_clipboard_macos(page_url):&#10;            show_macos_toast(&quot;发布链接已复制&quot;, seconds=3)&#10;&#10;        # Default speed: don't wait unless user explicitly wants it&#10;        if not args.no_wait:&#10;            print(&quot;⏳ 等待 GitHub Pages 部署生效...&quot;)&#10;            if wait_until_url_ready(page_url, timeout_seconds=180, interval_seconds=4.0):&#10;                print(&quot;✅ 页面已可访问。&quot;)&#10;            else:&#10;                print(&quot;ℹ️ 可能需要再等一会儿再刷新浏览器（GitHub Pages 有部署延迟）。&quot;)&#10;&#10;    except subprocess.CalledProcessError as e:&#10;        err = (e.stderr or &quot;&quot;).strip()&#10;        out = (e.output or &quot;&quot;).strip()&#10;        if out:&#10;            print(out)&#10;        if err:&#10;            print(err)&#10;        raise SystemExit(f&quot;命令失败: {e.cmd} (exit {e.returncode})&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/privacy_merge.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/privacy_merge.py" />
              <option name="originalContent" value="import html&#10;import sys&#10;import urllib&#10;import subprocess&#10;import os&#10;&#10;import requests&#10;from selenium import webdriver&#10;import time&#10;from selenium.webdriver.common.by import By&#10;from bs4 import BeautifulSoup&#10;from selenium.webdriver.support.wait import WebDriverWait&#10;&#10;import base64&#10;import gzip&#10;import json&#10;import re&#10;from io import BytesIO&#10;from pathlib import Path&#10;from DrissionPage import Chromium&#10;&#10;PRIVACY_GEN_URL = &quot;https://app-privacy-policy-generator.firebaseapp.com/&quot;&#10;table_url = &quot;https://superxgr.larksuite.com/base/SebGbrq2yaNXXSsVOcJudpzxsCf?table=tblTywpT1yCgOaV7&amp;view=vewOnkM00z&quot;&#10;api_keyword = &quot;SebGbrq2yaNXXSsVOcJudpzxsCf/records&quot;&#10;browser = None&#10;browser_port = 9527&#10;cookies_str = &quot;&quot;&#10;app_name: str = &quot;&quot;&#10;company_name: str = &quot;&quot;&#10;email: str = &quot;&quot;&#10;&#10;# 用于 finally 安全退出&#10;driver = None&#10;&#10;# 生成并发布静态页需要的输出文件&#10;PRIVACY_TEXT_OUT = Path(__file__).resolve().parent / &quot;privacy_text.txt&quot;&#10;&#10;&#10;def html_to_formatted_text(html_fragment: str) -&gt; str:&#10;    &quot;&quot;&quot;将 privacy_simple_content 的 innerHTML 转成较好粘贴的纯文本，保留段落、列表和链接结构。&quot;&quot;&quot;&#10;    if not html_fragment:&#10;        return &quot;&quot;&#10;    soup = BeautifulSoup(html_fragment, &quot;html.parser&quot;)&#10;&#10;    lines = []&#10;&#10;    from bs4.element import NavigableString, Tag&#10;&#10;    def handle_node(node, indent_level=0):&#10;        indent = &quot;  &quot; * indent_level&#10;&#10;        if isinstance(node, NavigableString):&#10;            text = str(node)&#10;            text = text.replace(&quot;\u200b&quot;, &quot;&quot;).strip(&quot;\n&quot;)&#10;            if text:&#10;                lines.append(indent + text)&#10;            return&#10;&#10;        if not isinstance(node, Tag):&#10;            return&#10;&#10;        name = (node.name or &quot;&quot;).lower()&#10;&#10;        if name == &quot;br&quot;:&#10;            lines.append(&quot;&quot;)&#10;            return&#10;&#10;        if name in {&quot;p&quot;, &quot;div&quot;, &quot;section&quot;, &quot;strong&quot;, &quot;b&quot;, &quot;em&quot;, &quot;i&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;}:&#10;            before = len(lines)&#10;            for child in node.children:&#10;                handle_node(child, indent_level)&#10;            after = len(lines)&#10;            if after &gt; before and (not lines or lines[-1] != &quot;&quot;):&#10;                lines.append(&quot;&quot;)&#10;            return&#10;&#10;        if name in {&quot;ul&quot;, &quot;ol&quot;}:&#10;            if lines and lines[-1] != &quot;&quot;:&#10;                lines.append(&quot;&quot;)&#10;            idx = 1&#10;            for li in node.find_all(&quot;li&quot;, recursive=False):&#10;                prefix = &quot;- &quot; if name == &quot;ul&quot; else f&quot;{idx}. &quot;&#10;                buf = []&#10;&#10;                def collect(child):&#10;                    if isinstance(child, NavigableString):&#10;                        t = str(child).replace(&quot;\u200b&quot;, &quot;&quot;).strip(&quot;\n&quot;)&#10;                        if t:&#10;                            buf.append(t)&#10;                    elif isinstance(child, Tag):&#10;                        cname = (child.name or &quot;&quot;).lower()&#10;                        if cname == &quot;br&quot;:&#10;                            buf.append(&quot; &quot;)&#10;                        elif cname == &quot;a&quot;:&#10;                            href = child.get(&quot;href&quot;) or &quot;&quot;&#10;                            visible = child.get_text(strip=True)&#10;                            if href and visible:&#10;                                buf.append(f&quot;{visible} ({href})&quot;)&#10;                            else:&#10;                                buf.append(visible or href)&#10;                        else:&#10;                            for g in child.children:&#10;                                collect(g)&#10;&#10;                for c in li.children:&#10;                    collect(c)&#10;                li_text = &quot;&quot;.join(buf)&#10;                li_text = re.sub(r&quot;\s+&quot;, &quot; &quot;, li_text).strip()&#10;                if li_text:&#10;                    lines.append(indent + prefix + li_text)&#10;                for sub in li.find_all([&quot;ul&quot;, &quot;ol&quot;], recursive=False):&#10;                    handle_node(sub, indent_level + 1)&#10;                if lines and lines[-1] != &quot;&quot;:&#10;                    lines.append(&quot;&quot;)&#10;                idx += 1&#10;            return&#10;&#10;        if name == &quot;a&quot;:&#10;            href = node.get(&quot;href&quot;) or &quot;&quot;&#10;            visible = node.get_text(strip=True)&#10;            if href and visible:&#10;                lines.append(indent + f&quot;{visible} ({href})&quot;)&#10;            else:&#10;                lines.append(indent + (visible or href))&#10;            return&#10;&#10;        for child in node.children:&#10;            handle_node(child, indent_level)&#10;&#10;    root = soup.find(id=&quot;privacy_simple_content&quot;) or soup&#10;    for c in root.children:&#10;        handle_node(c, 0)&#10;&#10;    out = []&#10;    blank = 0&#10;    for ln in lines:&#10;        if ln.strip() == &quot;&quot;:&#10;            blank += 1&#10;            if blank &lt;= 2:&#10;                out.append(&quot;&quot;)&#10;        else:&#10;            blank = 0&#10;            out.append(ln)&#10;&#10;    text = &quot;\n&quot;.join(out)&#10;    text = text.replace(&quot;\r\n&quot;, &quot;\n&quot;)&#10;    text = re.sub(r&quot;\n{3,}&quot;, &quot;\n\n&quot;, text).strip()&#10;    return text&#10;&#10;&#10;def copy_to_clipboard_macos(text: str) -&gt; bool:&#10;    &quot;&quot;&quot;在 macOS 使用 pbcopy 复制文本到系统剪贴板。&quot;&quot;&quot;&#10;    if not text:&#10;        return False&#10;    try:&#10;        subprocess.run([&quot;pbcopy&quot;], input=text.encode(&quot;utf-8&quot;), check=True)&#10;        print(&quot;✅ 已复制到系统剪贴板 (pbcopy)&quot;)&#10;        return True&#10;    except Exception as e:&#10;        print(f&quot;⚠️ 复制到剪贴板失败: {e}&quot;)&#10;        return False&#10;&#10;&#10;def get_gzip_json_from_api(timeout: int = 60):&#10;    &quot;&quot;&quot;&#10;    1. 监听接口捕获动态参数。&#10;    2. 手动扫码登录，刷新页面触发接口。&#10;    3. 修改捕获到的 URL，设置 offset=0。&#10;    4. 提取 Cookies，使用 requests 库重新发送请求。&#10;    5. 解析响应，解压 Gzip 数据。&#10;    &quot;&quot;&quot;&#10;    global browser&#10;    if browser is None:&#10;        browser = Chromium(browser_port)&#10;&#10;    tab = browser.latest_tab&#10;    tab.get(table_url)&#10;    print(f&quot; 开始监听接口: {api_keyword}&quot;)&#10;    tab.listen.start(api_keyword)&#10;&#10;    input(&quot;请扫码登录并按 Enter 继续 &gt;&gt;&gt; &quot;)&#10;    tab.refresh()  # 触发接口请求&#10;&#10;    print(f&quot; 开始捕获接口请求...&quot;)&#10;    # 等待接口触发&#10;    req = tab.listen.wait(timeout=timeout)&#10;    tab.listen.stop()  # 捕获到后停止监听&#10;&#10;    if not req:&#10;        print(f&quot;❌ {timeout} 秒内未捕获到接口请求。&quot;)&#10;        return None&#10;&#10;    # --- 1. 获取原始 URL 并修改 offset ---&#10;    original_url = req.url&#10;    print(f&quot;✅ 捕获到原始接口: {original_url}&quot;)&#10;&#10;    # 解析 URL 和查询参数&#10;    parsed_url = urllib.parse.urlparse(original_url)&#10;    query_params = urllib.parse.parse_qs(parsed_url.query)&#10;&#10;    # 修改 offset 参数为 0（获取所有数据）&#10;    query_params[&quot;offset&quot;] = [&quot;0&quot;]&#10;&#10;    # 重新构建查询字符串和完整的 URL&#10;    new_query_string = urllib.parse.urlencode(query_params, doseq=True)&#10;    new_url = urllib.parse.urlunparse(parsed_url._replace(query=new_query_string))&#10;&#10;    print(f&quot; 正在用修改后的 URL (后台请求): {new_url}&quot;)&#10;&#10;    # --- 2. 提取已登录的 Cookies ---&#10;    current_cookies = tab.cookies()&#10;&#10;    # 将 cookies 转换为字符串形式，作为 HTTP 请求的头部&#10;    cookies_str = &quot;; &quot;.join(&#10;        [f&quot;{cookie['name']}={cookie['value']}&quot; for cookie in current_cookies]&#10;    )&#10;&#10;    # 设置 headers，带上 cookies&#10;    headers = {&quot;Cookie&quot;: cookies_str}&#10;&#10;    # --- 3. 使用 requests 发送请求 ---&#10;    try:&#10;        response = requests.get(new_url, headers=headers, timeout=timeout)&#10;    except requests.exceptions.RequestException as e:&#10;        print(f&quot;❌ 请求失败: {e}&quot;)&#10;        return None&#10;&#10;    # --- 4. 检查和提取响应体 ---&#10;&#10;    if response.status_code != 200:&#10;        print(f&quot;❌ 重新请求失败！HTTP 状态码: {response.status_code}&quot;)&#10;        return None&#10;&#10;    resp_body_text = response.text&#10;&#10;    if not resp_body_text:&#10;        print(f&quot;❌ 重新请求成功 (200)，但响应体为空。&quot;)&#10;        return None&#10;&#10;    # --- 5. 解析 JSON 和 Gzip 解压 ---&#10;&#10;    try:&#10;        resp_json = json.loads(resp_body_text)&#10;    except Exception as e:&#10;        print(f&quot;⚠️ 响应不是合法 JSON：{e}\n原始内容: {resp_body_text[:200]}&quot;)&#10;        return None&#10;&#10;    # 提取 gzip Base64 数据&#10;    try:&#10;        gzip_base64_str = resp_json[&quot;data&quot;][&quot;records&quot;]&#10;    except KeyError:&#10;        print(&quot;❌ 未找到 data.records 字段，请检查返回结构。&quot;)&#10;        return None&#10;&#10;    try:&#10;        gzip_bytes = base64.b64decode(gzip_base64_str)&#10;        with gzip.GzipFile(fileobj=BytesIO(gzip_bytes)) as f:&#10;            decompressed_data = f.read().decode(&quot;utf-8&quot;)&#10;        records_json = json.loads(decompressed_data)&#10;    except Exception as e:&#10;        print(f&quot;❌ 解压或解析失败: {e}&quot;)&#10;        return None&#10;&#10;    print(&quot;✅ 成功解压 JSON 数据！&quot;)&#10;    return records_json, cookies_str&#10;&#10;&#10;try:&#10;    from selenium.webdriver.support import expected_conditions as EC&#10;except Exception:&#10;    EC = None&#10;&#10;&#10;def normalize_text(s):&#10;    if not s:&#10;        return &quot;&quot;&#10;    return s.replace('\u200b', '').strip()&#10;&#10;&#10;def ensure_check_checkbox(driver, checkbox_id, timeout=10):&#10;    &quot;&quot;&quot;&#10;    稳健选中 checkbox：滚动、点击 label 或 input，或后备设置 checked 并派发 change。&#10;    &quot;&quot;&quot;&#10;    end_time = time.time() + timeout&#10;    while time.time() &lt; end_time:&#10;        try:&#10;            input_el = WebDriverWait(driver, 1).until(&#10;                EC.presence_of_element_located((By.ID, checkbox_id))&#10;            )&#10;        except Exception:&#10;            driver.execute_script(&quot;window.scrollBy(0, 400);&quot;)&#10;            time.sleep(0.4)&#10;            continue&#10;&#10;        try:&#10;            label = driver.find_element(By.CSS_SELECTOR, f&quot;label[for=\&quot;{checkbox_id}\&quot;]&quot;)&#10;        except Exception:&#10;            label = None&#10;&#10;        target = label if label is not None else input_el&#10;        try:&#10;            driver.execute_script(&quot;arguments[0].scrollIntoView({block: 'center'});&quot;, target)&#10;            driver.execute_script(&quot;window.scrollBy(0, -80);&quot;)&#10;            time.sleep(0.25)&#10;        except Exception:&#10;            pass&#10;&#10;        clicked = False&#10;        if label:&#10;            try:&#10;                driver.execute_script(&quot;arguments[0].click();&quot;, label)&#10;                clicked = True&#10;            except Exception:&#10;                clicked = False&#10;&#10;        if not clicked:&#10;            try:&#10;                driver.execute_script(&quot;arguments[0].click();&quot;, input_el)&#10;                clicked = True&#10;            except Exception:&#10;                clicked = False&#10;&#10;        if not clicked:&#10;            try:&#10;                driver.execute_script(&#10;                    &quot;var el = document.getElementById(arguments[0]); if(el){ el.checked = true; el.dispatchEvent(new Event('change')); }&quot;,&#10;                    checkbox_id&#10;                )&#10;            except Exception:&#10;                pass&#10;&#10;        try:&#10;            is_checked = driver.execute_script(&#10;                &quot;var el = document.getElementById(arguments[0]); return !!(el &amp;&amp; el.checked);&quot;, checkbox_id)&#10;            if is_checked:&#10;                print(f&quot;✅ 已成功选中：{checkbox_id}&quot;)&#10;                return True&#10;        except Exception:&#10;            pass&#10;&#10;        time.sleep(0.4)&#10;&#10;    print(f&quot;❌ 无法选中 {checkbox_id}（超时）&quot;)&#10;    return False&#10;&#10;&#10;def click_next_footer(driver, timeout=5):&#10;    &quot;&quot;&quot;在页脚点击文本为 Next 的按钮&quot;&quot;&quot;&#10;    end = time.time() + timeout&#10;    while time.time() &lt; end:&#10;        buttons = driver.find_elements(By.CLASS_NAME, &quot;card-footer-item&quot;)&#10;        for btn in buttons:&#10;            try:&#10;                if btn.text.strip().lower() == &quot;next&quot;:&#10;                    btn.click()&#10;                    return True&#10;            except Exception:&#10;                continue&#10;        time.sleep(0.3)&#10;    return False&#10;&#10;&#10;def _toast_macos(message: str, title: str = &quot;PrivacyTools&quot;) -&gt; None:&#10;    &quot;&quot;&quot;macOS 通知（失败也不影响主流程）。&quot;&quot;&quot;&#10;    try:&#10;        if not message:&#10;            return&#10;        subprocess.run(&#10;            [&quot;osascript&quot;, &quot;-e&quot;, f'display notification &quot;{message}&quot; with title &quot;{title}&quot;'],&#10;            check=False,&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def _close_modal_if_possible(driver) -&gt; None:&#10;    &quot;&quot;&quot;尝试关闭弹窗，不行也不报错。&quot;&quot;&quot;&#10;    try:&#10;        btns = driver.find_elements(By.CSS_SELECTOR, &quot;.modal.is-active .delete&quot;)&#10;        if btns:&#10;            driver.execute_script(&quot;arguments[0].click();&quot;, btns[0])&#10;            time.sleep(0.2)&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def _run_git_push_main_with_env() -&gt; None:&#10;    &quot;&quot;&quot;用指定 SSH key/host 进行一次推送（避免默认走 git@github.com 触发权限错）。&quot;&quot;&quot;&#10;    env = os.environ.copy()&#10;    ssh_host = env.get(&quot;PRIVACY_PAGES_SSH_HOST&quot;, &quot;github-common-hosts&quot;)&#10;    ssh_key = env.get(&quot;PRIVACY_PAGES_SSH_KEY&quot;, str(Path(&quot;~/.ssh/id_ed25519_common_hosts&quot;).expanduser()))&#10;    env[&quot;GIT_SSH_COMMAND&quot;] = f&quot;ssh -i {ssh_key} -o IdentitiesOnly=yes&quot;&#10;&#10;    # 仅在有变更时 push，减少耗时&#10;    status = subprocess.run([&quot;git&quot;, &quot;status&quot;, &quot;--porcelain&quot;], cwd=str(Path(__file__).resolve().parent), text=True, capture_output=True)&#10;    if (status.stdout or &quot;&quot;).strip():&#10;        return&#10;&#10;    subprocess.run([&quot;git&quot;, &quot;push&quot;, ssh_host, &quot;main&quot;], cwd=str(Path(__file__).resolve().parent), env=env, check=False)&#10;&#10;&#10;def publish_privacy_page_to_github(app_title: str, publish_id: str, content_file: Path) -&gt; str:&#10;    &quot;&quot;&quot;调用 googleSites.py 生成并推送 pages/&lt;slug&gt;/index.html。&#10;&#10;    返回：发布后的 page_url（尽最大努力从输出中提取）。&#10;    &quot;&quot;&quot;&#10;    env = os.environ.copy()&#10;    env.setdefault(&quot;PRIVACY_PAGES_SSH_HOST&quot;, &quot;github-common-hosts&quot;)&#10;    env.setdefault(&quot;PRIVACY_PAGES_SSH_KEY&quot;, str(Path(&quot;~/.ssh/id_ed25519_common_hosts&quot;).expanduser()))&#10;&#10;    safe_title = (app_title or &quot;privacy-policy&quot;).strip() or &quot;privacy-policy&quot;&#10;    safe_id = (publish_id or &quot;&quot;).strip()&#10;&#10;    cmd = [&#10;        sys.executable,&#10;        str(Path(__file__).resolve().parent / &quot;googleSites.py&quot;),&#10;        &quot;--title&quot;,&#10;        safe_title,&#10;        &quot;--id&quot;,&#10;        safe_id,&#10;        &quot;--content-file&quot;,&#10;        str(content_file),&#10;        &quot;--commit-message&quot;,&#10;        f&quot;Publish privacy page: {safe_title}&quot;,&#10;    ]&#10;&#10;    # 这里不要 check=True；让我们能打印 stdout/stderr 给你看&#10;    p = subprocess.run(cmd, env=env, text=True, capture_output=True)&#10;    combined = (p.stdout or &quot;&quot;) + (&quot;\n&quot; + (p.stderr or &quot;&quot;) if p.stderr else &quot;&quot;)&#10;&#10;    if combined.strip():&#10;        print(&quot;------ googleSites.py 输出开始 ------&quot;)&#10;        print(combined.strip())&#10;        print(&quot;------ googleSites.py 输出结束 ------&quot;)&#10;&#10;    m = re.search(r&quot;(https?://[^\s]+/pages/[^\s]+/)&quot;, combined)&#10;    page_url = m.group(1) if m else &quot;&quot;&#10;&#10;    # 极端情况下 googleSites.py 里 push 失败，这里再用同一个 key/host 兜底推一次&#10;    if p.returncode != 0:&#10;        print(&quot;⚠️ googleSites.py 返回非 0，尝试兜底 push 一次...&quot;)&#10;        try:&#10;            _run_git_push_main_with_env()&#10;        except Exception:&#10;            pass&#10;&#10;    return page_url&#10;&#10;&#10;# python&#10;def extract_and_show_privacy_text(driver, wait_seconds=12, publish_id: str = &quot;&quot;):&#10;    driver.switch_to.default_content()&#10;    try:&#10;        WebDriverWait(driver, wait_seconds).until(&#10;            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;.modal.is-active #privacy_simple_content&quot;))&#10;        )&#10;    except Exception:&#10;        print(&quot;❌ 未检测到弹窗或 privacy_simple_content&quot;)&#10;        return None&#10;&#10;    # 直接获取元素的 innerHTML 而不是整页 HTML&#10;    try:&#10;        inner_html = driver.execute_script(&#10;            &quot;var el=document.getElementById('privacy_simple_content');return el?el.innerHTML:'';&quot;&#10;        )&#10;    except Exception as e:&#10;        print(f&quot;❌ 获取 innerHTML 失败: {e}&quot;)&#10;        return None&#10;&#10;    if not inner_html:&#10;        print(&quot;❌ privacy_simple_content.innerHTML 为空&quot;)&#10;        return None&#10;&#10;    text = html_to_formatted_text(inner_html)&#10;    if not text:&#10;        print(&quot;❌ 解析结果为空&quot;)&#10;        return None&#10;&#10;    # 1) 复制隐私文本到剪贴板 + toast&#10;    copy_to_clipboard_macos(text)&#10;    _toast_macos(&quot;隐私文本已复制&quot;, title=&quot;PrivacyTools&quot;)&#10;&#10;    # 2) 写出到文件给 GitHub Pages 发布用&#10;    try:&#10;        PRIVACY_TEXT_OUT.write_text(text, encoding=&quot;utf-8&quot;)&#10;        print(f&quot; 已写入隐私文本到文件: {PRIVACY_TEXT_OUT}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;⚠️ 写入隐私文本文件失败: {e}&quot;)&#10;&#10;    # 3) 控制台日志输出（可查）&#10;    print(&quot;------ Privacy Policy 文本开始 ------&quot;)&#10;    print(text)&#10;    print(&quot;------ Privacy Policy 文本结束 ------&quot;)&#10;&#10;    # 4) 复制完成后关闭网页/弹窗（先关 modal，再关 tab）&#10;    _close_modal_if_possible(driver)&#10;    try:&#10;        driver.close()&#10;    except Exception:&#10;        pass&#10;&#10;    # 5) 发布到 GitHub Pages：显示“网页发布中...”，成功后复制 URL + toast&#10;    publish_url = &quot;&quot;&#10;    try:&#10;        app_title = (app_name or &quot;privacy-policy&quot;).strip() or &quot;privacy-policy&quot;&#10;        print(&quot; 网页发布中。。。大概十几秒吧。。。&quot;)&#10;        publish_url = publish_privacy_page_to_github(app_title=app_title, publish_id=publish_id, content_file=PRIVACY_TEXT_OUT)&#10;&#10;        if publish_url:&#10;            print(f&quot; 已发布网页地址: {publish_url}&quot;)&#10;            copy_to_clipboard_macos(publish_url)&#10;            _toast_macos(&quot;隐私网页链接已复制&quot;, title=&quot;PrivacyTools&quot;)&#10;        else:&#10;            print(&quot;⚠️ 未能从发布输出中提取 URL（但通常仍可能已发布成功，请看 googleSites.py 输出）。&quot;)&#10;    except Exception as e:&#10;        print(f&quot;❌ 发布网页失败: {e}&quot;)&#10;&#10;    return publish_url&#10;&#10;&#10;# python&#10;def run_privacy_flow(driver, target_os=&quot;Android&quot;, publish_id: str = &quot;&quot;):&#10;    # 让 target_os 默认是 Android（且保证类型正确）&#10;    if not isinstance(target_os, str):&#10;        real_type = type(target_os).__name__&#10;        print(f&quot;❌ target_os 类型错误，期望字符串，实际为: {real_type}，将回退为 Android&quot;)&#10;        target_os = &quot;Android&quot;&#10;&#10;    driver.get(PRIVACY_GEN_URL)&#10;    try:&#10;        WebDriverWait(driver, 15).until(&#10;            EC.element_to_be_clickable((By.CLASS_NAME, &quot;start-btn&quot;))&#10;        ).click()&#10;    except Exception:&#10;        pass&#10;&#10;    # 等待 appName 输入出现&#10;    WebDriverWait(driver, 15).until(&#10;        EC.presence_of_element_located((By.ID, &quot;appName&quot;))&#10;    )&#10;    driver.find_element(By.ID, &quot;appName&quot;).clear()&#10;    driver.find_element(By.ID, &quot;appName&quot;).send_keys(app_name or &quot;&quot;)&#10;    driver.find_element(By.ID, &quot;appContact&quot;).clear()&#10;    driver.find_element(By.ID, &quot;appContact&quot;).send_keys(email or &quot;&quot;)&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;&#10;    # 继续点击 Next（可能需要多步）&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;    time.sleep(0.2)&#10;&#10;    # 选择 Mobile OS&#10;    radios = driver.find_elements(By.CSS_SELECTOR, 'input[type=&quot;radio&quot;]')&#10;    chosen = False&#10;    for r in radios:&#10;        try:&#10;            val = (r.get_attribute(&quot;value&quot;) or &quot;&quot;).strip()&#10;            if val and val.lower() == target_os.lower():&#10;                driver.execute_script(&#10;                    &quot;arguments[0].scrollIntoView({block:'center'});&quot;, r&#10;                )&#10;                r.click()&#10;                chosen = True&#10;                print(f&quot;✅ 已选择 Mobile OS: {target_os}&quot;)&#10;                break&#10;        except Exception:&#10;            continue&#10;    if not chosen:&#10;        # 打印页面里实际可用的 value，方便排查&#10;        available = []&#10;        for r in radios:&#10;            try:&#10;                v = (r.get_attribute(&quot;value&quot;) or &quot;&quot;).strip()&#10;                if v:&#10;                    available.append(v)&#10;            except Exception:&#10;                continue&#10;        print(&#10;            f&quot;❌ 没有找到 OS 选项: {target_os}，页面可用选项: {available or '[]'}&quot;&#10;        )&#10;&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;    time.sleep(0.2)&#10;&#10;    # 填写 Company Name&#10;    dev_input = driver.find_elements(By.ID, &quot;devName&quot;)&#10;    if dev_input:&#10;        el = dev_input[0]&#10;        el.clear()&#10;        el.send_keys(company_name or &quot;&quot;)&#10;        print(&quot;✅ 已填写 Company Name&quot;)&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;    time.sleep(0.2)&#10;&#10;    # 勾选第三方服务（示例 id 列表，可以根据页面实际 id 调整）&#10;    third_party_ids = [&#10;        &quot;list-switch-Google Analytics for Firebase&quot;,&#10;        &quot;list-switch-Firebase Crashlytics&quot;,&#10;        &quot;list-switch-Adjust&quot;,&#10;    ]&#10;    for cid in third_party_ids:&#10;        ensure_check_checkbox(driver, cid, timeout=6)&#10;        time.sleep(0.2)&#10;&#10;    # Next -&gt; Privacy Policy&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;    time.sleep(0.2)&#10;&#10;    # 点击 Privacy Policy 按钮&#10;    footer_links = driver.find_elements(By.CLASS_NAME, &quot;card-footer-item&quot;)&#10;    clicked_priv = False&#10;    for link in footer_links:&#10;        try:&#10;            if link.text.strip().lower() == &quot;privacy policy&quot;:&#10;                link.click()&#10;                clicked_priv = True&#10;                print(&quot;✅ 已点击 Privacy Policy&quot;)&#10;                break&#10;        except Exception:&#10;            continue&#10;    if not clicked_priv:&#10;        print(&quot;❌ 没有找到 Privacy Policy 按钮&quot;)&#10;    extract_and_show_privacy_text(driver, publish_id=publish_id)&#10;    return True&#10;&#10;&#10;# def create_driver(headless=False, user_data_dir=None, profile_dir=None):&#10;#     opts = webdriver.ChromeOptions()&#10;#     opts.add_argument('--start-maximized')&#10;#     if headless:&#10;#         opts.add_argument('--headless=new')&#10;#     if user_data_dir:&#10;#         opts.add_argument(f'--user-data-dir={user_data_dir}')&#10;#     if profile_dir:&#10;#         opts.add_argument(f'--profile-directory={profile_dir}')&#10;#     return webdriver.Chrome(options=opts)&#10;&#10;from selenium import webdriver&#10;from selenium.webdriver.chrome.service import Service&#10;from webdriver_manager.chrome import ChromeDriverManager&#10;&#10;def create_driver(headless=False, user_data_dir=None, profile_dir=None, chrome_binary=None):&#10;    opts = webdriver.ChromeOptions()&#10;    opts.add_argument('--start-maximized')&#10;    if headless:&#10;        opts.add_argument('--headless=new')&#10;    if user_data_dir:&#10;        opts.add_argument(f'--user-data-dir={user_data_dir}')&#10;    if profile_dir:&#10;        opts.add_argument(f'--profile-directory={profile_dir}')&#10;    if chrome_binary:&#10;        opts.binary_location = chrome_binary  # 可选：显式指定 Chrome 可执行文件路径&#10;    service = Service(ChromeDriverManager().install())  # 自动下载并使用匹配的 chromedriver&#10;    return webdriver.Chrome(service=service, options=opts)&#10;&#10;&#10;def find_and_collect_by_target_value(json_obj, target_value=None):&#10;    &quot;&quot;&quot;&#10;    按订单号筛选并在找到时把 app_name 写入全局变量 app_name，继续返回结果列表。&#10;    &quot;&quot;&quot;&#10;    # 顶层函数本身不直接读写 app_name，只在内部嵌套函数里操作&#10;&#10;    if not target_value:&#10;        print(&quot;❌ 需要提供 target_value (订单编号)，例如 'IGT1185'&quot;)&#10;        return []&#10;&#10;    results = []&#10;    target_str = str(target_value).strip().lower()&#10;&#10;    def _search(obj):&#10;        # 这里显式声明使用全局 app_name，避免 UnboundLocalError&#10;        global app_name&#10;&#10;        if isinstance(obj, dict):&#10;            fld_order = obj.get(&quot;fldxQWjXD7&quot;)&#10;            if isinstance(fld_order, dict):&#10;                val = fld_order.get(&quot;value&quot;)&#10;                if isinstance(val, list):&#10;                    for entry in val:&#10;                        if isinstance(entry, dict):&#10;                            text = (entry.get(&quot;text&quot;) or &quot;&quot;).strip()&#10;                            if text.lower() == target_str:&#10;                                # 提取 app_name（来自 fldaShB3Gb 的第一个 value 的 text）&#10;                                found_app_name = None&#10;                                flda = obj.get(&quot;fldaShB3Gb&quot;)&#10;                                if isinstance(flda, dict):&#10;                                    fval = flda.get(&quot;value&quot;)&#10;                                    if isinstance(fval, list) and fval:&#10;                                        first = fval[0]&#10;                                        if isinstance(first, dict):&#10;                                            found_app_name = (first.get(&quot;text&quot;) or &quot;&quot;).strip() or None&#10;&#10;                                # 尝试在 fldnLglcRi 中写入 app_name 并返回其第一个 value&#10;                                fldn = obj.get(&quot;fldnLglcRi&quot;)&#10;                                if isinstance(fldn, dict):&#10;                                    v = fldn.get(&quot;value&quot;)&#10;                                    if isinstance(v, list) and v:&#10;                                        first_item = v[0]&#10;                                        if isinstance(first_item, dict):&#10;                                            if found_app_name:&#10;                                                first_item[&quot;app_name&quot;] = found_app_name&#10;                                            results.append(first_item)&#10;                                        else:&#10;                                            new_item = {&quot;value&quot;: first_item}&#10;                                            if found_app_name:&#10;                                                new_item[&quot;app_name&quot;] = found_app_name&#10;                                            results.append(new_item)&#10;                                    else:&#10;                                        new_item = {}&#10;                                        if found_app_name:&#10;                                            new_item[&quot;app_name&quot;] = found_app_name&#10;                                        results.append(new_item)&#10;                                else:&#10;                                    if found_app_name:&#10;                                        results.append({&quot;app_name&quot;: found_app_name})&#10;                                    else:&#10;                                        results.append(obj)&#10;&#10;                                # 无论之前是否有值，直接把找到的 app_name 赋给全局变量&#10;                                if found_app_name:&#10;                                    app_name = found_app_name&#10;                                    print(f&quot; 已设置全局 app_name = `{app_name}`&quot;)&#10;&#10;                                break&#10;&#10;            # 继续递归查找子节点&#10;            for v in obj.values():&#10;                _search(v)&#10;&#10;        elif isinstance(obj, list):&#10;            for item in obj:&#10;                _search(item)&#10;&#10;    _search(json_obj)&#10;    return results&#10;&#10;&#10;def extract_vps_array_from_doc22(doc_data, cookies_str):&#10;    global company_name, email&#10;    print(&quot; 提取页面中首个有效的 @gmail.com 邮箱...&quot;)&#10;    results = []&#10;    seen_urls = set()&#10;&#10;    headers = {&#10;        &quot;Cookie&quot;: cookies_str or &quot;&quot;,&#10;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/123.0 Safari/537.36&quot;,&#10;    }&#10;&#10;    email_re = re.compile(r'(?&lt;![A-Za-z0-9._%+\-])([A-Za-z0-9._%+\-]+@gmail\.com)\b', re.I)&#10;&#10;    def _clean_gmail_emails(raw_text):&#10;        found = email_re.findall(raw_text or &quot;&quot;)&#10;        unique = []&#10;        seen = set()&#10;        for e in found:&#10;            ne = e.strip().lower()&#10;            if ne and ne not in seen:&#10;                seen.add(ne)&#10;                unique.append(ne)&#10;        final = []&#10;        sset = set(unique)&#10;        for e in unique:&#10;            if len(e) &gt; 1 and e[1:] in sset and len(e[0]) == 1:&#10;                continue&#10;            final.append(e)&#10;        return final&#10;&#10;    for item in doc_data:&#10;        url = item.get(&quot;link&quot;)&#10;        text = item.get(&quot;text&quot;, &quot;&quot;)&#10;        if not url and not text:&#10;            continue&#10;        if url in seen_urls:&#10;            continue&#10;&#10;        try:&#10;            response = requests.get(url, headers=headers, timeout=15)&#10;            if response.status_code != 200:&#10;                print(f&quot;❌ 请求失败: {url}, 状态码: {response.status_code}&quot;)&#10;                continue&#10;&#10;            page_content = html.unescape(response.text or &quot;&quot;)&#10;            emails = _clean_gmail_emails(page_content)&#10;            primary = emails[0] if emails else &quot;&quot;&#10;&#10;            # 首次发现时，设置全局 company_name 和 email（如果尚未设置）&#10;            if not company_name:&#10;                t = (text or &quot;&quot;).strip()&#10;                m = re.search(r'-(.+)$', t)&#10;                if m:&#10;                    company_name = m.group(1).strip()&#10;                else:&#10;                    parts = t.split(None, 1)&#10;                    company_name = parts[1].strip() if len(parts) &gt; 1 else (t or &quot;&quot;)&#10;&#10;            if primary and not email:&#10;                email = primary.strip().lower()&#10;&#10;            results.append(&#10;                {&#10;                    &quot;text&quot;: text,&#10;                    &quot;url&quot;: url,&#10;                    &quot;email&quot;: primary,&#10;                }&#10;            )&#10;            seen_urls.add(url)&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ 解析失败: {url}, 错误: {e}&quot;)&#10;&#10;        # 如果全局信息都已填充，可以选择提前退出以加快速度&#10;        if company_name and email:&#10;            break&#10;&#10;    # 按 text 中的数字排序（保持原有行为）&#10;    def _extract_number(t):&#10;        m = re.search(r&quot;(\d+)&quot;, (t or &quot;&quot;))&#10;        return int(m.group(1)) if m else 0&#10;&#10;    results.sort(key=lambda x: _extract_number(x.get(&quot;text&quot;)))&#10;&#10;    for item in results:&#10;        print(f&quot;{item.get('text')}&quot;)&#10;        if item.get('email'):&#10;            print(f&quot;  邮箱: {item.get('email')}&quot;)&#10;        else:&#10;            print(&quot;  邮箱: 未发现 @gmail.com 地址&quot;)&#10;        print(&quot;-&quot; * 50)&#10;&#10;    print(f&quot;✅ 总数量: {len(results)}&quot;)&#10;    return results&#10;&#10;&#10;def save_to_json(data, filename=&quot;none.json&quot;):&#10;    Path(filename).write_text(json.dumps(data, ensure_ascii=False, indent=2))&#10;    # print(f&quot;✅ 已保存 {len(data)} 条结果到 {filename}&quot;)&#10;&#10;&#10;import argparse&#10;&#10;&#10;def ensure_github_ssh_keychain_ready(key_path: str = &quot;~/.ssh/id_ed25519_common_hosts&quot;) -&gt; None:&#10;    &quot;&quot;&quot;One-time helper: load SSH key into macOS Keychain/ssh-agent.&#10;&#10;    Why you see:&#10;      Identity added: ...&#10;    Because ssh-add prints that line to stdout when it loads a key.&#10;&#10;    Here we:&#10;      - detect if the key is already loaded (by comparing the .pub key body)&#10;      - only run ssh-add when needed&#10;      - silence ssh-add output to keep logs clean&#10;    &quot;&quot;&quot;&#10;&#10;    def _pub_key_body(pub_text: str) -&gt; str:&#10;        # pub format: &quot;ssh-ed25519 AAAAC3... comment&quot;&#10;        parts = (pub_text or &quot;&quot;).strip().split()&#10;        return parts[1] if len(parts) &gt;= 2 else &quot;&quot;&#10;&#10;    try:&#10;        kp = Path(key_path).expanduser()&#10;        if not kp.exists():&#10;            return&#10;&#10;        pub_path = Path(str(kp) + &quot;.pub&quot;)&#10;        if not pub_path.exists():&#10;            return&#10;&#10;        want_body = _pub_key_body(pub_path.read_text(encoding=&quot;utf-8&quot;))&#10;        if not want_body:&#10;            return&#10;&#10;        # If already loaded, do nothing&#10;        p = subprocess.run([&quot;ssh-add&quot;, &quot;-L&quot;], text=True, capture_output=True)&#10;        if p.returncode == 0 and want_body in (p.stdout or &quot;&quot;):&#10;            return&#10;&#10;        # Load into agent/keychain (silence output; avoid noisy 'Identity added ...')&#10;        p = subprocess.run(&#10;            [&quot;ssh-add&quot;, &quot;--apple-use-keychain&quot;, str(kp)],&#10;            text=True,&#10;            capture_output=True,&#10;        )&#10;        if p.returncode != 0:&#10;            print(&#10;                &quot;⚠️ SSH key 预加载失败。你可以手动执行一次：\n&quot;&#10;                f&quot;  ssh-add --apple-use-keychain {kp}\n&quot;&#10;                &quot;输入 passphrase 后，以后脚本运行就不会再提示。&quot;&#10;            )&#10;    except Exception:&#10;        pass&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # 在真正运行 git push 之前先尝试预加载一次&#10;    ensure_github_ssh_keychain_ready()&#10;&#10;    parser = argparse.ArgumentParser()&#10;    parser.add_argument('id', nargs='?', help='表格中查找的编号，例如 IGT1128')&#10;    args = parser.parse_args()&#10;&#10;    # 交互获取 id（若未通过命令行提供）&#10;    if not args.id:&#10;        try:&#10;            args.id = input(&quot;请输入编号（例如 IGT1128）：&quot;).strip()&#10;        except (EOFError, KeyboardInterrupt):&#10;            args.id = None&#10;&#10;    if not args.id:&#10;        print(&quot;❌ 未提供编号，脚本将退出。\n示例用法：python privacys.py IGT1128 --scan&quot;)&#10;        sys.exit(2)&#10;&#10;    try:&#10;        records, cookies_str = get_gzip_json_from_api()&#10;        if not records:&#10;            print(&quot;❌ 未能获取 records，脚本退出&quot;)&#10;            sys.exit(1)&#10;&#10;        available_records = find_and_collect_by_target_value(records, target_value=args.id)&#10;        vps_result = extract_vps_array_from_doc22(available_records, cookies_str)&#10;&#10;        driver = create_driver()&#10;        run_privacy_flow(driver=driver, target_os=&quot;Android&quot;, publish_id=args.id)&#10;    finally:&#10;        if driver is not None:&#10;            try:&#10;                driver.quit()&#10;            except Exception:&#10;                pass&#10;" />
              <option name="updatedContent" value="import html&#10;import sys&#10;import urllib&#10;import subprocess&#10;import os&#10;&#10;import requests&#10;from selenium import webdriver&#10;import time&#10;from selenium.webdriver.common.by import By&#10;from bs4 import BeautifulSoup&#10;from selenium.webdriver.support.wait import WebDriverWait&#10;&#10;import base64&#10;import gzip&#10;import json&#10;import re&#10;from io import BytesIO&#10;from pathlib import Path&#10;from DrissionPage import Chromium&#10;&#10;PRIVACY_GEN_URL = &quot;https://app-privacy-policy-generator.firebaseapp.com/&quot;&#10;table_url = &quot;https://superxgr.larksuite.com/base/SebGbrq2yaNXXSsVOcJudpzxsCf?table=tblTywpT1yCgOaV7&amp;view=vewOnkM00z&quot;&#10;api_keyword = &quot;SebGbrq2yaNXXSsVOcJudpzxsCf/records&quot;&#10;browser = None&#10;browser_port = 9527&#10;cookies_str = &quot;&quot;&#10;app_name: str = &quot;&quot;&#10;company_name: str = &quot;&quot;&#10;email: str = &quot;&quot;&#10;&#10;# 用于 finally 安全退出&#10;driver = None&#10;&#10;# 生成并发布静态页需要的输出文件&#10;PRIVACY_TEXT_OUT = Path(__file__).resolve().parent / &quot;privacy_text.txt&quot;&#10;&#10;&#10;def html_to_formatted_text(html_fragment: str) -&gt; str:&#10;    &quot;&quot;&quot;将 privacy_simple_content 的 innerHTML 转成较好粘贴的纯文本，保留段落、列表和链接结构。&quot;&quot;&quot;&#10;    if not html_fragment:&#10;        return &quot;&quot;&#10;    soup = BeautifulSoup(html_fragment, &quot;html.parser&quot;)&#10;&#10;    lines = []&#10;&#10;    from bs4.element import NavigableString, Tag&#10;&#10;    def handle_node(node, indent_level=0):&#10;        indent = &quot;  &quot; * indent_level&#10;&#10;        if isinstance(node, NavigableString):&#10;            text = str(node)&#10;            text = text.replace(&quot;\u200b&quot;, &quot;&quot;).strip(&quot;\n&quot;)&#10;            if text:&#10;                lines.append(indent + text)&#10;            return&#10;&#10;        if not isinstance(node, Tag):&#10;            return&#10;&#10;        name = (node.name or &quot;&quot;).lower()&#10;&#10;        if name == &quot;br&quot;:&#10;            lines.append(&quot;&quot;)&#10;            return&#10;&#10;        if name in {&quot;p&quot;, &quot;div&quot;, &quot;section&quot;, &quot;strong&quot;, &quot;b&quot;, &quot;em&quot;, &quot;i&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;}:&#10;            before = len(lines)&#10;            for child in node.children:&#10;                handle_node(child, indent_level)&#10;            after = len(lines)&#10;            if after &gt; before and (not lines or lines[-1] != &quot;&quot;):&#10;                lines.append(&quot;&quot;)&#10;            return&#10;&#10;        if name in {&quot;ul&quot;, &quot;ol&quot;}:&#10;            if lines and lines[-1] != &quot;&quot;:&#10;                lines.append(&quot;&quot;)&#10;            idx = 1&#10;            for li in node.find_all(&quot;li&quot;, recursive=False):&#10;                prefix = &quot;- &quot; if name == &quot;ul&quot; else f&quot;{idx}. &quot;&#10;                buf = []&#10;&#10;                def collect(child):&#10;                    if isinstance(child, NavigableString):&#10;                        t = str(child).replace(&quot;\u200b&quot;, &quot;&quot;).strip(&quot;\n&quot;)&#10;                        if t:&#10;                            buf.append(t)&#10;                    elif isinstance(child, Tag):&#10;                        cname = (child.name or &quot;&quot;).lower()&#10;                        if cname == &quot;br&quot;:&#10;                            buf.append(&quot; &quot;)&#10;                        elif cname == &quot;a&quot;:&#10;                            href = child.get(&quot;href&quot;) or &quot;&quot;&#10;                            visible = child.get_text(strip=True)&#10;                            if href and visible:&#10;                                buf.append(f&quot;{visible} ({href})&quot;)&#10;                            else:&#10;                                buf.append(visible or href)&#10;                        else:&#10;                            for g in child.children:&#10;                                collect(g)&#10;&#10;                for c in li.children:&#10;                    collect(c)&#10;                li_text = &quot;&quot;.join(buf)&#10;                li_text = re.sub(r&quot;\s+&quot;, &quot; &quot;, li_text).strip()&#10;                if li_text:&#10;                    lines.append(indent + prefix + li_text)&#10;                for sub in li.find_all([&quot;ul&quot;, &quot;ol&quot;], recursive=False):&#10;                    handle_node(sub, indent_level + 1)&#10;                if lines and lines[-1] != &quot;&quot;:&#10;                    lines.append(&quot;&quot;)&#10;                idx += 1&#10;            return&#10;&#10;        if name == &quot;a&quot;:&#10;            href = node.get(&quot;href&quot;) or &quot;&quot;&#10;            visible = node.get_text(strip=True)&#10;            if href and visible:&#10;                lines.append(indent + f&quot;{visible} ({href})&quot;)&#10;            else:&#10;                lines.append(indent + (visible or href))&#10;            return&#10;&#10;        for child in node.children:&#10;            handle_node(child, indent_level)&#10;&#10;    root = soup.find(id=&quot;privacy_simple_content&quot;) or soup&#10;    for c in root.children:&#10;        handle_node(c, 0)&#10;&#10;    out = []&#10;    blank = 0&#10;    for ln in lines:&#10;        if ln.strip() == &quot;&quot;:&#10;            blank += 1&#10;            if blank &lt;= 2:&#10;                out.append(&quot;&quot;)&#10;        else:&#10;            blank = 0&#10;            out.append(ln)&#10;&#10;    text = &quot;\n&quot;.join(out)&#10;    text = text.replace(&quot;\r\n&quot;, &quot;\n&quot;)&#10;    text = re.sub(r&quot;\n{3,}&quot;, &quot;\n\n&quot;, text).strip()&#10;    return text&#10;&#10;&#10;def copy_to_clipboard_macos(text: str) -&gt; bool:&#10;    &quot;&quot;&quot;在 macOS 使用 pbcopy 复制文本到系统剪贴板。&quot;&quot;&quot;&#10;    if not text:&#10;        return False&#10;    try:&#10;        subprocess.run([&quot;pbcopy&quot;], input=text.encode(&quot;utf-8&quot;), check=True)&#10;        print(&quot;✅ 已复制到系统剪贴板 (pbcopy)&quot;)&#10;        return True&#10;    except Exception as e:&#10;        print(f&quot;⚠️ 复制到剪贴板失败: {e}&quot;)&#10;        return False&#10;&#10;&#10;def get_gzip_json_from_api(timeout: int = 60):&#10;    &quot;&quot;&quot;&#10;    1. 监听接口捕获动态参数。&#10;    2. 手动扫码登录，刷新页面触发接口。&#10;    3. 修改捕获到的 URL，设置 offset=0。&#10;    4. 提取 Cookies，使用 requests 库重新发送请求。&#10;    5. 解析响应，解压 Gzip 数据。&#10;    &quot;&quot;&quot;&#10;    global browser&#10;    if browser is None:&#10;        browser = Chromium(browser_port)&#10;&#10;    tab = browser.latest_tab&#10;    tab.get(table_url)&#10;    print(f&quot; 开始监听接口: {api_keyword}&quot;)&#10;    tab.listen.start(api_keyword)&#10;&#10;    input(&quot;请扫码登录并按 Enter 继续 &gt;&gt;&gt; &quot;)&#10;    tab.refresh()  # 触发接口请求&#10;&#10;    print(f&quot; 开始捕获接口请求...&quot;)&#10;    # 等待接口触发&#10;    req = tab.listen.wait(timeout=timeout)&#10;    tab.listen.stop()  # 捕获到后停止监听&#10;&#10;    if not req:&#10;        print(f&quot;❌ {timeout} 秒内未捕获到接口请求。&quot;)&#10;        return None&#10;&#10;    # --- 1. 获取原始 URL 并修改 offset ---&#10;    original_url = req.url&#10;    print(f&quot;✅ 捕获到原始接口: {original_url}&quot;)&#10;&#10;    # 解析 URL 和查询参数&#10;    parsed_url = urllib.parse.urlparse(original_url)&#10;    query_params = urllib.parse.parse_qs(parsed_url.query)&#10;&#10;    # 修改 offset 参数为 0（获取所有数据）&#10;    query_params[&quot;offset&quot;] = [&quot;0&quot;]&#10;&#10;    # 重新构建查询字符串和完整的 URL&#10;    new_query_string = urllib.parse.urlencode(query_params, doseq=True)&#10;    new_url = urllib.parse.urlunparse(parsed_url._replace(query=new_query_string))&#10;&#10;    print(f&quot; 正在用修改后的 URL (后台请求): {new_url}&quot;)&#10;&#10;    # --- 2. 提取已登录的 Cookies ---&#10;    current_cookies = tab.cookies()&#10;&#10;    # 将 cookies 转换为字符串形式，作为 HTTP 请求的头部&#10;    cookies_str = &quot;; &quot;.join(&#10;        [f&quot;{cookie['name']}={cookie['value']}&quot; for cookie in current_cookies]&#10;    )&#10;&#10;    # 设置 headers，带上 cookies&#10;    headers = {&quot;Cookie&quot;: cookies_str}&#10;&#10;    # --- 3. 使用 requests 发送请求 ---&#10;    try:&#10;        response = requests.get(new_url, headers=headers, timeout=timeout)&#10;    except requests.exceptions.RequestException as e:&#10;        print(f&quot;❌ 请求失败: {e}&quot;)&#10;        return None&#10;&#10;    # --- 4. 检查和提取响应体 ---&#10;&#10;    if response.status_code != 200:&#10;        print(f&quot;❌ 重新请求失败！HTTP 状态码: {response.status_code}&quot;)&#10;        return None&#10;&#10;    resp_body_text = response.text&#10;&#10;    if not resp_body_text:&#10;        print(f&quot;❌ 重新请求成功 (200)，但响应体为空。&quot;)&#10;        return None&#10;&#10;    # --- 5. 解析 JSON 和 Gzip 解压 ---&#10;&#10;    try:&#10;        resp_json = json.loads(resp_body_text)&#10;    except Exception as e:&#10;        print(f&quot;⚠️ 响应不是合法 JSON：{e}\n原始内容: {resp_body_text[:200]}&quot;)&#10;        return None&#10;&#10;    # 提取 gzip Base64 数据&#10;    try:&#10;        gzip_base64_str = resp_json[&quot;data&quot;][&quot;records&quot;]&#10;    except KeyError:&#10;        print(&quot;❌ 未找到 data.records 字段，请检查返回结构。&quot;)&#10;        return None&#10;&#10;    try:&#10;        gzip_bytes = base64.b64decode(gzip_base64_str)&#10;        with gzip.GzipFile(fileobj=BytesIO(gzip_bytes)) as f:&#10;            decompressed_data = f.read().decode(&quot;utf-8&quot;)&#10;        records_json = json.loads(decompressed_data)&#10;    except Exception as e:&#10;        print(f&quot;❌ 解压或解析失败: {e}&quot;)&#10;        return None&#10;&#10;    print(&quot;✅ 成功解压 JSON 数据！&quot;)&#10;    return records_json, cookies_str&#10;&#10;&#10;try:&#10;    from selenium.webdriver.support import expected_conditions as EC&#10;except Exception:&#10;    EC = None&#10;&#10;&#10;def normalize_text(s):&#10;    if not s:&#10;        return &quot;&quot;&#10;    return s.replace('\u200b', '').strip()&#10;&#10;&#10;def ensure_check_checkbox(driver, checkbox_id, timeout=10):&#10;    &quot;&quot;&quot;&#10;    稳健选中 checkbox：滚动、点击 label 或 input，或后备设置 checked 并派发 change。&#10;    &quot;&quot;&quot;&#10;    end_time = time.time() + timeout&#10;    while time.time() &lt; end_time:&#10;        try:&#10;            input_el = WebDriverWait(driver, 1).until(&#10;                EC.presence_of_element_located((By.ID, checkbox_id))&#10;            )&#10;        except Exception:&#10;            driver.execute_script(&quot;window.scrollBy(0, 400);&quot;)&#10;            time.sleep(0.4)&#10;            continue&#10;&#10;        try:&#10;            label = driver.find_element(By.CSS_SELECTOR, f&quot;label[for=\&quot;{checkbox_id}\&quot;]&quot;)&#10;        except Exception:&#10;            label = None&#10;&#10;        target = label if label is not None else input_el&#10;        try:&#10;            driver.execute_script(&quot;arguments[0].scrollIntoView({block: 'center'});&quot;, target)&#10;            driver.execute_script(&quot;window.scrollBy(0, -80);&quot;)&#10;            time.sleep(0.25)&#10;        except Exception:&#10;            pass&#10;&#10;        clicked = False&#10;        if label:&#10;            try:&#10;                driver.execute_script(&quot;arguments[0].click();&quot;, label)&#10;                clicked = True&#10;            except Exception:&#10;                clicked = False&#10;&#10;        if not clicked:&#10;            try:&#10;                driver.execute_script(&quot;arguments[0].click();&quot;, input_el)&#10;                clicked = True&#10;            except Exception:&#10;                clicked = False&#10;&#10;        if not clicked:&#10;            try:&#10;                driver.execute_script(&#10;                    &quot;var el = document.getElementById(arguments[0]); if(el){ el.checked = true; el.dispatchEvent(new Event('change')); }&quot;,&#10;                    checkbox_id&#10;                )&#10;            except Exception:&#10;                pass&#10;&#10;        try:&#10;            is_checked = driver.execute_script(&#10;                &quot;var el = document.getElementById(arguments[0]); return !!(el &amp;&amp; el.checked);&quot;, checkbox_id)&#10;            if is_checked:&#10;                print(f&quot;✅ 已成功选中：{checkbox_id}&quot;)&#10;                return True&#10;        except Exception:&#10;            pass&#10;&#10;        time.sleep(0.4)&#10;&#10;    print(f&quot;❌ 无法选中 {checkbox_id}（超时）&quot;)&#10;    return False&#10;&#10;&#10;def click_next_footer(driver, timeout=5):&#10;    &quot;&quot;&quot;在页脚点击文本为 Next 的按钮&quot;&quot;&quot;&#10;    end = time.time() + timeout&#10;    while time.time() &lt; end:&#10;        buttons = driver.find_elements(By.CLASS_NAME, &quot;card-footer-item&quot;)&#10;        for btn in buttons:&#10;            try:&#10;                if btn.text.strip().lower() == &quot;next&quot;:&#10;                    btn.click()&#10;                    return True&#10;            except Exception:&#10;                continue&#10;        time.sleep(0.3)&#10;    return False&#10;&#10;&#10;def _toast_macos(message: str, title: str = &quot;PrivacyTools&quot;) -&gt; None:&#10;    &quot;&quot;&quot;macOS 通知（失败也不影响主流程）。&quot;&quot;&quot;&#10;    try:&#10;        if not message:&#10;            return&#10;        subprocess.run(&#10;            [&quot;osascript&quot;, &quot;-e&quot;, f'display notification &quot;{message}&quot; with title &quot;{title}&quot;'],&#10;            check=False,&#10;            capture_output=True,&#10;            text=True,&#10;        )&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def _close_modal_if_possible(driver) -&gt; None:&#10;    &quot;&quot;&quot;尝试关闭弹窗，不行也不报错。&quot;&quot;&quot;&#10;    try:&#10;        btns = driver.find_elements(By.CSS_SELECTOR, &quot;.modal.is-active .delete&quot;)&#10;        if btns:&#10;            driver.execute_script(&quot;arguments[0].click();&quot;, btns[0])&#10;            time.sleep(0.2)&#10;    except Exception:&#10;        pass&#10;&#10;&#10;# &#10;# GitHub Pages / SSH helpers&#10;# &#10;&#10;&#10;def ensure_github_ssh_keychain_ready(key_path: str = &quot;~/.ssh/id_ed25519_common_hosts&quot;) -&gt; None:&#10;    &quot;&quot;&quot;Teammate-friendly: don't spam `ssh-add` output and don't block on passphrase.&#10;&#10;    We only *check* whether key is loaded. If not loaded, we print a one-time hint.&#10;    Loading should be done manually once:&#10;      ssh-add --apple-use-keychain ~/.ssh/id_ed25519_common_hosts&#10;    &quot;&quot;&quot;&#10;&#10;    def _pub_key_body(pub_text: str) -&gt; str:&#10;        parts = (pub_text or &quot;&quot;).strip().split()&#10;        return parts[1] if len(parts) &gt;= 2 else &quot;&quot;&#10;&#10;    try:&#10;        kp = Path(key_path).expanduser()&#10;        if not kp.exists():&#10;            return&#10;&#10;        pub_path = Path(str(kp) + &quot;.pub&quot;)&#10;        if not pub_path.exists():&#10;            return&#10;&#10;        want_body = _pub_key_body(pub_path.read_text(encoding=&quot;utf-8&quot;))&#10;        if not want_body:&#10;            return&#10;&#10;        p = subprocess.run([&quot;ssh-add&quot;, &quot;-L&quot;], text=True, capture_output=True)&#10;        if p.returncode == 0 and want_body in (p.stdout or &quot;&quot;):&#10;            return&#10;&#10;        print(&#10;            &quot;\n⚠️ 检测到 GitHub Pages 的 SSH key 还未加载到 ssh-agent（或未保存到 Keychain）。\n&quot;&#10;            &quot;请在终端手动执行一次（只需一次）：\n&quot;&#10;            f&quot;  ssh-add --apple-use-keychain {kp}\n&quot;&#10;            &quot;输入 passphrase 后，以后脚本运行就不会再提示。\n&quot;&#10;        )&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def _run_git_push_main_with_env() -&gt; None:&#10;    &quot;&quot;&quot;Best-effort fallback push using the preferred SSH host alias.&#10;&#10;    Note: We do NOT pass '-i key' here to avoid interactive passphrase prompts.&#10;    Use ssh-agent+Keychain for non-interactive use.&#10;    &quot;&quot;&quot;&#10;    env = os.environ.copy()&#10;    env.setdefault(&quot;PRIVACY_PAGES_SSH_HOST&quot;, &quot;github-common-hosts&quot;)&#10;&#10;    env[&quot;GIT_SSH_COMMAND&quot;] = (&#10;        &quot;ssh -o BatchMode=yes -o IdentitiesOnly=yes &quot;&#10;        &quot;-o StrictHostKeyChecking=accept-new &quot;&#10;        &quot;-o ControlMaster=auto -o ControlPersist=10m -o ControlPath=~/.ssh/cm-%r@%h:%p&quot;&#10;    )&#10;&#10;    repo_root = Path(__file__).resolve().parent&#10;&#10;    # push regardless of status (commit may already exist)&#10;    subprocess.run([&quot;git&quot;, &quot;push&quot;, &quot;origin&quot;, &quot;main&quot;], cwd=str(repo_root), env=env, check=False)&#10;&#10;&#10;def publish_privacy_page_to_github(app_title: str, publish_id: str, content_file: Path) -&gt; str:&#10;    &quot;&quot;&quot;Call googleSites.py to generate &amp; push pages/&lt;slug&gt;/index.html.&#10;&#10;    Return: published page URL (best-effort parsed).&#10;    &quot;&quot;&quot;&#10;    env = os.environ.copy()&#10;    env.setdefault(&quot;PRIVACY_PAGES_SSH_HOST&quot;, &quot;github-common-hosts&quot;)&#10;    env.setdefault(&quot;PRIVACY_PAGES_SSH_KEY&quot;, str(Path(&quot;~/.ssh/id_ed25519_common_hosts&quot;).expanduser()))&#10;&#10;    safe_title = (app_title or &quot;privacy-policy&quot;).strip() or &quot;privacy-policy&quot;&#10;    safe_id = (publish_id or &quot;&quot;).strip()&#10;&#10;    cmd = [&#10;        sys.executable,&#10;        str(Path(__file__).resolve().parent / &quot;googleSites.py&quot;),&#10;        &quot;--title&quot;,&#10;        safe_title,&#10;        &quot;--id&quot;,&#10;        safe_id,&#10;        &quot;--content-file&quot;,&#10;        str(content_file),&#10;        &quot;--commit-message&quot;,&#10;        f&quot;Publish privacy page: {safe_title}&quot;,&#10;        &quot;--no-wait&quot;,&#10;    ]&#10;&#10;    p = subprocess.run(cmd, env=env, text=True, capture_output=True)&#10;    combined = (p.stdout or &quot;&quot;) + (&quot;\n&quot; + (p.stderr or &quot;&quot;) if p.stderr else &quot;&quot;)&#10;&#10;    if combined.strip():&#10;        print(&quot;------ googleSites.py 输出开始 ------&quot;)&#10;        print(combined.strip())&#10;        print(&quot;------ googleSites.py 输出结束 ------&quot;)&#10;&#10;    m = re.search(r&quot;(https?://[^\s]+/pages/[^\s]+/)&quot;, combined)&#10;    page_url = m.group(1) if m else &quot;&quot;&#10;&#10;    if p.returncode != 0:&#10;        print(&quot;⚠️ googleSites.py 返回非 0，尝试兜底 push 一次...&quot;)&#10;        try:&#10;            _run_git_push_main_with_env()&#10;        except Exception:&#10;            pass&#10;&#10;    return page_url&#10;&#10;&#10;def extract_and_show_privacy_text(driver, wait_seconds=12, publish_id: str = &quot;&quot;):&#10;    driver.switch_to.default_content()&#10;    try:&#10;        WebDriverWait(driver, wait_seconds).until(&#10;            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;.modal.is-active #privacy_simple_content&quot;))&#10;        )&#10;    except Exception:&#10;        print(&quot;❌ 未检测到弹窗或 privacy_simple_content&quot;)&#10;        return None&#10;&#10;    # 直接获取元素的 innerHTML 而不是整页 HTML&#10;    try:&#10;        inner_html = driver.execute_script(&#10;            &quot;var el=document.getElementById('privacy_simple_content');return el?el.innerHTML:'';&quot;&#10;        )&#10;    except Exception as e:&#10;        print(f&quot;❌ 获取 innerHTML 失败: {e}&quot;)&#10;        return None&#10;&#10;    if not inner_html:&#10;        print(&quot;❌ privacy_simple_content.innerHTML 为空&quot;)&#10;        return None&#10;&#10;    text = html_to_formatted_text(inner_html)&#10;    if not text:&#10;        print(&quot;❌ 解析结果为空&quot;)&#10;        return None&#10;&#10;    # 1) 复制隐私文本到剪贴板 + toast&#10;    copy_to_clipboard_macos(text)&#10;    _toast_macos(&quot;隐私文本已复制&quot;, title=&quot;PrivacyTools&quot;)&#10;&#10;    # 2) 写出到文件给 GitHub Pages 发布用&#10;    try:&#10;        PRIVACY_TEXT_OUT.write_text(text, encoding=&quot;utf-8&quot;)&#10;        print(f&quot; 已写入隐私文本到文件: {PRIVACY_TEXT_OUT}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;⚠️ 写入隐私文本文件失败: {e}&quot;)&#10;&#10;    # 3) 控制台日志输出（可查）&#10;    print(&quot;------ Privacy Policy 文本开始 ------&quot;)&#10;    print(text)&#10;    print(&quot;------ Privacy Policy 文本结束 ------&quot;)&#10;&#10;    # 4) 复制完成后关闭网页/弹窗（先关 modal，再关 tab）&#10;    _close_modal_if_possible(driver)&#10;    try:&#10;        driver.close()&#10;    except Exception:&#10;        pass&#10;&#10;    # 5) 发布到 GitHub Pages：显示“网页发布中...”，成功后复制 URL + toast&#10;    publish_url = &quot;&quot;&#10;    try:&#10;        app_title = (app_name or &quot;privacy-policy&quot;).strip() or &quot;privacy-policy&quot;&#10;        print(&quot; 网页发布中。。。大概十几秒吧。。。&quot;)&#10;        publish_url = publish_privacy_page_to_github(app_title=app_title, publish_id=publish_id, content_file=PRIVACY_TEXT_OUT)&#10;&#10;        if publish_url:&#10;            print(f&quot; 已发布网页地址: {publish_url}&quot;)&#10;            copy_to_clipboard_macos(publish_url)&#10;            _toast_macos(&quot;隐私网页链接已复制&quot;, title=&quot;PrivacyTools&quot;)&#10;        else:&#10;            print(&quot;⚠️ 未能从发布输出中提取 URL（但通常仍可能已发布成功，请看 googleSites.py 输出）。&quot;)&#10;    except Exception as e:&#10;        print(f&quot;❌ 发布网页失败: {e}&quot;)&#10;&#10;    return publish_url&#10;&#10;&#10;# python&#10;def run_privacy_flow(driver, target_os=&quot;Android&quot;, publish_id: str = &quot;&quot;):&#10;    # 让 target_os 默认是 Android（且保证类型正确）&#10;    if not isinstance(target_os, str):&#10;        real_type = type(target_os).__name__&#10;        print(f&quot;❌ target_os 类型错误，期望字符串，实际为: {real_type}，将回退为 Android&quot;)&#10;        target_os = &quot;Android&quot;&#10;&#10;    driver.get(PRIVACY_GEN_URL)&#10;    try:&#10;        WebDriverWait(driver, 15).until(&#10;            EC.element_to_be_clickable((By.CLASS_NAME, &quot;start-btn&quot;))&#10;        ).click()&#10;    except Exception:&#10;        pass&#10;&#10;    # 等待 appName 输入出现&#10;    WebDriverWait(driver, 15).until(&#10;        EC.presence_of_element_located((By.ID, &quot;appName&quot;))&#10;    )&#10;    driver.find_element(By.ID, &quot;appName&quot;).clear()&#10;    driver.find_element(By.ID, &quot;appName&quot;).send_keys(app_name or &quot;&quot;)&#10;    driver.find_element(By.ID, &quot;appContact&quot;).clear()&#10;    driver.find_element(By.ID, &quot;appContact&quot;).send_keys(email or &quot;&quot;)&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;&#10;    # 继续点击 Next（可能需要多步）&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;    time.sleep(0.2)&#10;&#10;    # 选择 Mobile OS&#10;    radios = driver.find_elements(By.CSS_SELECTOR, 'input[type=&quot;radio&quot;]')&#10;    chosen = False&#10;    for r in radios:&#10;        try:&#10;            val = (r.get_attribute(&quot;value&quot;) or &quot;&quot;).strip()&#10;            if val and val.lower() == target_os.lower():&#10;                driver.execute_script(&#10;                    &quot;arguments[0].scrollIntoView({block:'center'});&quot;, r&#10;                )&#10;                r.click()&#10;                chosen = True&#10;                print(f&quot;✅ 已选择 Mobile OS: {target_os}&quot;)&#10;                break&#10;        except Exception:&#10;            continue&#10;    if not chosen:&#10;        # 打印页面里实际可用的 value，方便排查&#10;        available = []&#10;        for r in radios:&#10;            try:&#10;                v = (r.get_attribute(&quot;value&quot;) or &quot;&quot;).strip()&#10;                if v:&#10;                    available.append(v)&#10;            except Exception:&#10;                continue&#10;        print(&#10;            f&quot;❌ 没有找到 OS 选项: {target_os}，页面可用选项: {available or '[]'}&quot;&#10;        )&#10;&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;    time.sleep(0.2)&#10;&#10;    # 填写 Company Name&#10;    dev_input = driver.find_elements(By.ID, &quot;devName&quot;)&#10;    if dev_input:&#10;        el = dev_input[0]&#10;        el.clear()&#10;        el.send_keys(company_name or &quot;&quot;)&#10;        print(&quot;✅ 已填写 Company Name&quot;)&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;    time.sleep(0.2)&#10;&#10;    # 勾选第三方服务（示例 id 列表，可以根据页面实际 id 调整）&#10;    third_party_ids = [&#10;        &quot;list-switch-Google Analytics for Firebase&quot;,&#10;        &quot;list-switch-Firebase Crashlytics&quot;,&#10;        &quot;list-switch-Adjust&quot;,&#10;    ]&#10;    for cid in third_party_ids:&#10;        ensure_check_checkbox(driver, cid, timeout=6)&#10;        time.sleep(0.2)&#10;&#10;    # Next -&gt; Privacy Policy&#10;    time.sleep(0.2)&#10;    click_next_footer(driver)&#10;    time.sleep(0.2)&#10;&#10;    # 点击 Privacy Policy 按钮&#10;    footer_links = driver.find_elements(By.CLASS_NAME, &quot;card-footer-item&quot;)&#10;    clicked_priv = False&#10;    for link in footer_links:&#10;        try:&#10;            if link.text.strip().lower() == &quot;privacy policy&quot;:&#10;                link.click()&#10;                clicked_priv = True&#10;                print(&quot;✅ 已点击 Privacy Policy&quot;)&#10;                break&#10;        except Exception:&#10;            continue&#10;    if not clicked_priv:&#10;        print(&quot;❌ 没有找到 Privacy Policy 按钮&quot;)&#10;    extract_and_show_privacy_text(driver, publish_id=publish_id)&#10;    return True&#10;&#10;&#10;# def create_driver(headless=False, user_data_dir=None, profile_dir=None):&#10;#     opts = webdriver.ChromeOptions()&#10;#     opts.add_argument('--start-maximized')&#10;#     if headless:&#10;#         opts.add_argument('--headless=new')&#10;#     if user_data_dir:&#10;#         opts.add_argument(f'--user-data-dir={user_data_dir}')&#10;#     if profile_dir:&#10;#         opts.add_argument(f'--profile-directory={profile_dir}')&#10;#     return webdriver.Chrome(options=opts)&#10;&#10;from selenium import webdriver&#10;from selenium.webdriver.chrome.service import Service&#10;from webdriver_manager.chrome import ChromeDriverManager&#10;&#10;def create_driver(headless=False, user_data_dir=None, profile_dir=None, chrome_binary=None):&#10;    opts = webdriver.ChromeOptions()&#10;    opts.add_argument('--start-maximized')&#10;    if headless:&#10;        opts.add_argument('--headless=new')&#10;    if user_data_dir:&#10;        opts.add_argument(f'--user-data-dir={user_data_dir}')&#10;    if profile_dir:&#10;        opts.add_argument(f'--profile-directory={profile_dir}')&#10;    if chrome_binary:&#10;        opts.binary_location = chrome_binary  # 可选：显式指定 Chrome 可执行文件路径&#10;    service = Service(ChromeDriverManager().install())  # 自动下载并使用匹配的 chromedriver&#10;    return webdriver.Chrome(service=service, options=opts)&#10;&#10;&#10;def find_and_collect_by_target_value(json_obj, target_value=None):&#10;    &quot;&quot;&quot;&#10;    按订单号筛选并在找到时把 app_name 写入全局变量 app_name，继续返回结果列表。&#10;    &quot;&quot;&quot;&#10;    # 顶层函数本身不直接读写 app_name，只在内部嵌套函数里操作&#10;&#10;    if not target_value:&#10;        print(&quot;❌ 需要提供 target_value (订单编号)，例如 'IGT1185'&quot;)&#10;        return []&#10;&#10;    results = []&#10;    target_str = str(target_value).strip().lower()&#10;&#10;    def _search(obj):&#10;        # 这里显式声明使用全局 app_name，避免 UnboundLocalError&#10;        global app_name&#10;&#10;        if isinstance(obj, dict):&#10;            fld_order = obj.get(&quot;fldxQWjXD7&quot;)&#10;            if isinstance(fld_order, dict):&#10;                val = fld_order.get(&quot;value&quot;)&#10;                if isinstance(val, list):&#10;                    for entry in val:&#10;                        if isinstance(entry, dict):&#10;                            text = (entry.get(&quot;text&quot;) or &quot;&quot;).strip()&#10;                            if text.lower() == target_str:&#10;                                # 提取 app_name（来自 fldaShB3Gb 的第一个 value 的 text）&#10;                                found_app_name = None&#10;                                flda = obj.get(&quot;fldaShB3Gb&quot;)&#10;                                if isinstance(flda, dict):&#10;                                    fval = flda.get(&quot;value&quot;)&#10;                                    if isinstance(fval, list) and fval:&#10;                                        first = fval[0]&#10;                                        if isinstance(first, dict):&#10;                                            found_app_name = (first.get(&quot;text&quot;) or &quot;&quot;).strip() or None&#10;&#10;                                # 尝试在 fldnLglcRi 中写入 app_name 并返回其第一个 value&#10;                                fldn = obj.get(&quot;fldnLglcRi&quot;)&#10;                                if isinstance(fldn, dict):&#10;                                    v = fldn.get(&quot;value&quot;)&#10;                                    if isinstance(v, list) and v:&#10;                                        first_item = v[0]&#10;                                        if isinstance(first_item, dict):&#10;                                            if found_app_name:&#10;                                                first_item[&quot;app_name&quot;] = found_app_name&#10;                                            results.append(first_item)&#10;                                        else:&#10;                                            new_item = {&quot;value&quot;: first_item}&#10;                                            if found_app_name:&#10;                                                new_item[&quot;app_name&quot;] = found_app_name&#10;                                            results.append(new_item)&#10;                                    else:&#10;                                        new_item = {}&#10;                                        if found_app_name:&#10;                                            new_item[&quot;app_name&quot;] = found_app_name&#10;                                        results.append(new_item)&#10;                                else:&#10;                                    if found_app_name:&#10;                                        results.append({&quot;app_name&quot;: found_app_name})&#10;                                    else:&#10;                                        results.append(obj)&#10;&#10;                                # 无论之前是否有值，直接把找到的 app_name 赋给全局变量&#10;                                if found_app_name:&#10;                                    app_name = found_app_name&#10;                                    print(f&quot; 已设置全局 app_name = `{app_name}`&quot;)&#10;&#10;                                break&#10;&#10;            # 继续递归查找子节点&#10;            for v in obj.values():&#10;                _search(v)&#10;&#10;        elif isinstance(obj, list):&#10;            for item in obj:&#10;                _search(item)&#10;&#10;    _search(json_obj)&#10;    return results&#10;&#10;&#10;def extract_vps_array_from_doc22(doc_data, cookies_str):&#10;    global company_name, email&#10;    print(&quot; 提取页面中首个有效的 @gmail.com 邮箱...&quot;)&#10;    results = []&#10;    seen_urls = set()&#10;&#10;    headers = {&#10;        &quot;Cookie&quot;: cookies_str or &quot;&quot;,&#10;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/123.0 Safari/537.36&quot;,&#10;    }&#10;&#10;    email_re = re.compile(r'(?&lt;![A-Za-z0-9._%+\-])([A-Za-z0-9._%+\-]+@gmail\.com)\b', re.I)&#10;&#10;    def _clean_gmail_emails(raw_text):&#10;        found = email_re.findall(raw_text or &quot;&quot;)&#10;        unique = []&#10;        seen = set()&#10;        for e in found:&#10;            ne = e.strip().lower()&#10;            if ne and ne not in seen:&#10;                seen.add(ne)&#10;                unique.append(ne)&#10;        final = []&#10;        sset = set(unique)&#10;        for e in unique:&#10;            if len(e) &gt; 1 and e[1:] in sset and len(e[0]) == 1:&#10;                continue&#10;            final.append(e)&#10;        return final&#10;&#10;    for item in doc_data:&#10;        url = item.get(&quot;link&quot;)&#10;        text = item.get(&quot;text&quot;, &quot;&quot;)&#10;        if not url and not text:&#10;            continue&#10;        if url in seen_urls:&#10;            continue&#10;&#10;        try:&#10;            response = requests.get(url, headers=headers, timeout=15)&#10;            if response.status_code != 200:&#10;                print(f&quot;❌ 请求失败: {url}, 状态码: {response.status_code}&quot;)&#10;                continue&#10;&#10;            page_content = html.unescape(response.text or &quot;&quot;)&#10;            emails = _clean_gmail_emails(page_content)&#10;            primary = emails[0] if emails else &quot;&quot;&#10;&#10;            # 首次发现时，设置全局 company_name 和 email（如果尚未设置）&#10;            if not company_name:&#10;                t = (text or &quot;&quot;).strip()&#10;                m = re.search(r'-(.+)$', t)&#10;                if m:&#10;                    company_name = m.group(1).strip()&#10;                else:&#10;                    parts = t.split(None, 1)&#10;                    company_name = parts[1].strip() if len(parts) &gt; 1 else (t or &quot;&quot;)&#10;&#10;            if primary and not email:&#10;                email = primary.strip().lower()&#10;&#10;            results.append(&#10;                {&#10;                    &quot;text&quot;: text,&#10;                    &quot;url&quot;: url,&#10;                    &quot;email&quot;: primary,&#10;                }&#10;            )&#10;            seen_urls.add(url)&#10;&#10;        except Exception as e:&#10;            print(f&quot;❌ 解析失败: {url}, 错误: {e}&quot;)&#10;&#10;        # 如果全局信息都已填充，可以选择提前退出以加快速度&#10;        if company_name and email:&#10;            break&#10;&#10;    # 按 text 中的数字排序（保持原有行为）&#10;    def _extract_number(t):&#10;        m = re.search(r&quot;(\d+)&quot;, (t or &quot;&quot;))&#10;        return int(m.group(1)) if m else 0&#10;&#10;    results.sort(key=lambda x: _extract_number(x.get(&quot;text&quot;)))&#10;&#10;    for item in results:&#10;        print(f&quot;{item.get('text')}&quot;)&#10;        if item.get('email'):&#10;            print(f&quot;  邮箱: {item.get('email')}&quot;)&#10;        else:&#10;            print(&quot;  邮箱: 未发现 @gmail.com 地址&quot;)&#10;        print(&quot;-&quot; * 50)&#10;&#10;    print(f&quot;✅ 总数量: {len(results)}&quot;)&#10;    return results&#10;&#10;&#10;def save_to_json(data, filename=&quot;none.json&quot;):&#10;    Path(filename).write_text(json.dumps(data, ensure_ascii=False, indent=2))&#10;    # print(f&quot;✅ 已保存 {len(data)} 条结果到 {filename}&quot;)&#10;&#10;&#10;import argparse&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # 在运行 push 之前只做一次检查：如果 key 没加载，会提示同事执行一次 ssh-add&#10;    ensure_github_ssh_keychain_ready()&#10;&#10;    parser = argparse.ArgumentParser()&#10;    parser.add_argument('id', nargs='?', help='表格中查找的编号，例如 IGT1128')&#10;    args = parser.parse_args()&#10;&#10;    # 交互获取 id（若未通过命令行提供）&#10;    if not args.id:&#10;        try:&#10;            args.id = input(&quot;请输入编号（例如 IGT1128）：&quot;).strip()&#10;        except (EOFError, KeyboardInterrupt):&#10;            args.id = None&#10;&#10;    if not args.id:&#10;        print(&quot;❌ 未提供编号，脚本将退出。\n示例用法：python privacys.py IGT1128 --scan&quot;)&#10;        sys.exit(2)&#10;&#10;    try:&#10;        records, cookies_str = get_gzip_json_from_api()&#10;        if not records:&#10;            print(&quot;❌ 未能获取 records，脚本退出&quot;)&#10;            sys.exit(1)&#10;&#10;        available_records = find_and_collect_by_target_value(records, target_value=args.id)&#10;        vps_result = extract_vps_array_from_doc22(available_records, cookies_str)&#10;&#10;        driver = create_driver()&#10;        run_privacy_flow(driver=driver, target_os=&quot;Android&quot;, publish_id=args.id)&#10;    finally:&#10;        if driver is not None:&#10;            try:&#10;                driver.quit()&#10;            except Exception:&#10;                pass" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>